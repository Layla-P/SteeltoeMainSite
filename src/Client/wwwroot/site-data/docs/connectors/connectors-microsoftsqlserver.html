<h1 id="microsoft-sql-server">Microsoft SQL Server</h1>
<p>This connector simplifies using Microsoft SQL Server in an application running on Cloud Foundry. The connector is built to work with <code>System.Data.SqlClient</code> and provides additional extension methods for using Entity Framework.</p>
<p>This connector provides a <code>IHealthContributor</code> which you can use in conjunction with the <a href="https://steeltoe.io/docs/steeltoe-management/#1-2-3-health">Steeltoe Management Health</a> check endpoint.  See the <a href="#using-health-contributors">Using Health Contributors</a> section for details on how to make use of it.</p>
<p>The source code for this connector can be found <a href="https://github.com/SteeltoeOSS/Connectors">here</a>.</p>
<h2 id="usage">Usage</h2>
<p>You should know how the new .NET <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration service</a> works before starting to use the connector. You need a basic understanding of the <code>ConfigurationBuilder</code> and how to add providers to the builder to configure the connector.</p>
<p>You should also know how the ASP.NET Core <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup">Startup</a> class is used in configuring the application services. Pay particular attention to the usage of the <code>ConfigureServices()</code> method.</p>
<p>To use this connector:</p>
<ol>
<li>Create a Microsoft SQL Service instance and bind it to your application.</li>
<li>Optionally, configure any Microsoft SQL Server client settings (such as <code>appsettings.json</code>) you need.</li>
<li>Add the Steeltoe Cloud Foundry configuration provider to your <code>ConfigurationBuilder</code>.</li>
<li>Add <code>SqlConnection</code> or <code>DbContext</code> to your <code>IServiceCollection</code>.</li>
</ol>
<h3 id="add-nuget-reference">Add NuGet Reference</h3>
<p>To use the Microsoft SQL Server connector, add your choice of Microsoft SQL Server package between <a href="https://www.nuget.org/packages/System.Data.SqlClient/">System.Data.SqlClient</a>, <a href="https://www.nuget.org/packages/EntityFramework/">Entity Framework</a> and <a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.SqlServer/">Microsoft.EntityFrameworkCore.SqlServer</a>, as you would if you weren't using Steeltoe. Then, add a reference to the appropriate <a href="#add-nuget-references">Steeltoe Connector NuGet package</a>.</p>
<h3 id="configure-settings">Configure Settings</h3>
<p>The Microsoft SQL Server connector supports several configuration options. These settings can be used to develop or test an application locally and then be overridden during deployment.</p>
<p>The following Microsoft SQL Server connector configuration shows how to connect to SQL Server 2016 Express LocalDB:</p>
<pre><code class="language-json">{
  ...
  &quot;sqlserver&quot;: {
    &quot;credentials&quot;: {
        &quot;connectionString&quot;: &quot;Server=(localdb)\\mssqllocaldb;database=Steeltoe;Trusted_Connection=True;&quot;
    }
  }
  ...
}
</code></pre>
<p>The following table shows the available settings for the connector:</p>
<table class="table">
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Steeltoe Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>Hostname or IP Address of server</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>Port number of server</td>
<td>1433</td>
</tr>
<tr>
<td>username</td>
<td>Username for authentication</td>
<td>not set</td>
</tr>
<tr>
<td>password</td>
<td>Password for authentication</td>
<td>not set</td>
</tr>
<tr>
<td>database</td>
<td>Schema to which to connect</td>
<td>not set</td>
</tr>
<tr>
<td>connectionString</td>
<td>Full connection string</td>
<td>built from settings</td>
</tr>
<tr>
<td>integratedSecurity</td>
<td>Enable Windows Authentication (For local use only)</td>
<td>not set</td>
</tr>
<tr>
<td>urlEncodedCredentials</td>
<td>Set to <code>true</code> if your service broker provides URL-encoded credentials</td>
<td>false</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>IMPORTANT: All of the settings shown in the preceding table should be prefixed with <code>sqlserver:credentials:</code>.</p>
</blockquote>
<p>The samples and most templates are already set up to read from <code>appsettings.json</code>. See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<blockquote class="blockquote">
<p>NOTE: If a ConnectionString is provided and VCAP_SERVICES are not detected (a typical scenario for local app development), the ConnectionString will be used exactly as provided.</p>
</blockquote>
<h3 id="cloud-foundry">Cloud Foundry</h3>
<p>To use Microsoft SQL Server on Cloud Foundry, you need a service instance bound to your application. If the <a href="https://github.com/cf-platform-eng/mssql-server-broker">Microsoft SQL Server broker</a> is installed in your Cloud Foundry instance, use it to create a new service instance, as follows:</p>
<pre><code class="language-bash">cf create-service SqlServer sharedVM mySqlServerService
</code></pre>
<p>An alternative to the broker is to use a user-provided service to explicitly provide connection information to the application, as shown in the following example:</p>
<pre><code class="language-bash">cf cups mySqlServerService -p '{&quot;pw&quot;: &quot;|password|&quot;,&quot;uid&quot;: &quot;|user id|&quot;,&quot;uri&quot;: &quot;jdbc:sqlserver://|host|:|port|;databaseName=|database name|&quot;}'
</code></pre>
<p>Version 2.1.1+ of this connector works with the <a href="https://docs.pivotal.io/partners/azure-open-service-broker-pcf/index.html">Azure Open Service Broker for PCF</a>. Be sure to set <code>sqlServer:client:urlEncodedCredentials</code> to <code>true</code> as this broker may provide credentials that have been URL Encoded.</p>
<p>If you are creating a service for an application that has already been deployed, you need to bind the service and restart or restage the application with the following commands:</p>
<pre><code class="language-bash"># Bind service to `myApp`
cf bind-service myApp mySqlServerService

# Restage the app to pick up change
cf restage myApp
</code></pre>
<p>If you have not already deployed the application, a reference in the <code>manifest.yml</code> file can take care of the binding for you.</p>
<blockquote class="blockquote">
<p>NOTE: The commands shown in the preceding example may not exactly match the service or plan names available in your environment. You may have to adjust the <code>create-service</code> command to fit your environment. Use <code>cf marketplace</code> to see what is available.</p>
</blockquote>
<p>Once the service is bound to your application, the connector's settings are available in <code>VCAP_SERVICES</code>. See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<h3 id="add-sqlconnection">Add SqlConnection</h3>
<p>To use a <code>SqlConnection</code> in your application, add it to the service container in the <code>ConfigureServices()</code> method of the <code>Startup</code> class, as shown in the following example:</p>
<pre><code class="language-csharp">using Steeltoe.CloudFoundry.Connector.SqlServer;

public class Startup {
    ...
    public IConfiguration Configuration { get; private set; }
    public Startup(...)
    {
      ...
    }
    public void ConfigureServices(IServiceCollection services)
    {
        // Add SqlConnection configured from Configuration
        services.AddSqlServerConnection(Configuration);

        // Add framework services.
        services.AddMvc();
        ...
    }
    ...
</code></pre>
<p>The <code>AddSqlServerConnection(Configuration)</code> method call shown in the previous example configures the <code>SqlConnection</code> by using the configuration built by the application and adds the connection to the service container.</p>
<h3 id="use-sqlconnection">Use SqlConnection</h3>
<p>Once you have configured and added the connection to the service container, you can inject it and use it in a controller or a view, as shown in the following example:</p>
<pre><code class="language-csharp">using System.Data.SqlClient;
...
public class HomeController : Controller
{
    public IActionResult SqlData([FromServices] SqlConnection dbConnection)
    {
        dbConnection.Open();

        MySqlCommand cmd = new MySqlCommand(&quot;SELECT * FROM TestData;&quot;, dbConnection);
        MySqlDataReader rdr = cmd.ExecuteReader();

        while (rdr.Read())
        {
            ViewData[&quot;Key&quot; + rdr[0]] = rdr[1];
        }

        rdr.Close();
        dbConnection.Close();

        return View();
    }
}
</code></pre>
<blockquote class="blockquote">
<p>NOTE: The preceding code does not create a database or a table or insert data. As written, it fails unless you create the database, table, and data ahead of time.</p>
</blockquote>
<h3 id="add-dbcontext">Add DbContext</h3>
<h4 id="entity-framework-6">Entity Framework 6</h4>
<p>To use the Microsoft SQL connector with Entity Framework 6, inject a DbContext into your application using the AddDbContext&lt;&gt;() method (provided by Steeltoe) that takes an IConfiguration as a parameter, as shown in the following example:</p>
<pre><code class="language-csharp">using Steeltoe.CloudFoundry.Connector.SqlServer.EF6;

public class Startup {
    ...
    public IConfiguration Configuration { get; private set; }
    public Startup(...)
    {
      ...
    }
    public void ConfigureServices(IServiceCollection services)
    {
        ...
        services.AddDbContext&lt;TestContext&gt;(Configuration);
        ...
    }
    ...
</code></pre>
<p>The <code>AddDbContext&lt;TestContext&gt;(..)</code> method call configures <code>TestContext</code> by using the configuration built earlier and then adds the <code>DbContext</code> (<code>TestContext</code>) to the service container.</p>
<p>Your <code>DbContext</code> does not need to be modified from a standard EF6 <code>DbContext</code> to work with Steeltoe:</p>
<pre><code class="language-csharp">using System.Data.Entity;
...

public class TestContext : DbContext
{
    public TestContext(string connectionString) : base(connectionString)
    {
    }
    public DbSet&lt;TestData&gt; TestData { get; set; }
}
</code></pre>
<h4 id="entity-framework-core">Entity Framework Core</h4>
<p>To use the Microsoft SQL Server connector with Entity Framework Core, inject a <code>DbContext</code> into your application with the standard <code>AddDbContext&lt;&gt;()</code> method, substituting Steeltoe’s <code>UseSqlServer</code> method that takes an <code>IConfiguration</code> as a parameter in the options configuration for the standard <code>UseSqlServer</code> method. This example demonstrates the basic usage:</p>
<pre><code class="language-csharp">using Steeltoe.CloudFoundry.Connector.SqlServer.EFCore;

public class Startup {
    ...
    public IConfiguration Configuration { get; private set; }
    public Startup(...)
    {
      ...
    }
    public void ConfigureServices(IServiceCollection services)
    {
        ...
        services.AddDbContext&lt;TestContext&gt;(options =&gt; options.UseSqlServer(Configuration));
        ...
    }
    ...
</code></pre>
<p>Your <code>DbContext</code> does not need to be modified from a standard <code>DbContext</code> to work with Steeltoe:</p>
<pre><code class="language-csharp">using Microsoft.EntityFrameworkCore;
...

public class TestContext : DbContext
{
    public TestContext(DbContextOptions options) : base(options)
    {

    }
    public DbSet&lt;TestData&gt; TestData { get; set; }
}

</code></pre>
<p>If you need to set additional properties for the <code>DbContext</code> like <code>MigrationsAssembly</code> or connection retry settings, create an <code>Action&lt;SqlServerDbContextOptionsBuilder&gt;</code> like this:</p>
<pre><code class="language-csharp">Action&lt;SqlServerDbContextOptionsBuilder&gt; sqlServerOptionsAction = (o) =&gt;
{
  o.MigrationsAssembly(typeof(Startup).GetTypeInfo().Assembly.GetName().Name);
  // Configuring Connection Resiliency: https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-resiliency
  o.EnableRetryOnFailure(maxRetryCount: 15, maxRetryDelay: TimeSpan.FromSeconds(30), errorNumbersToAdd: null);
};
</code></pre>
<p>Pass your new options action into the AddDbContext method:</p>
<pre><code class="language-csharp">services.AddDbContext&lt;TestContext&gt;(options =&gt; options.UseSqlServer(Configuration, sqlServerOptionsAction));
</code></pre>
<h3 id="use-dbcontext">Use DbContext</h3>
<p>Once you have configured and added the DbContext to the service container, you can inject it and use it in a controller or a view, as shown in the following example:</p>
<pre><code class="language-csharp">using Project.Models;
...
public class HomeController : Controller
{
    public IActionResult SqlData([FromServices] TestContext context)
    {
        return View(context.TestData.ToList());
    }
</code></pre>
