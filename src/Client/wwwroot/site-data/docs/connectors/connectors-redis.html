<h1 id="redis">Redis</h1>
<p>This connector simplifies using a Microsoft <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed#using-a-redis-distributed-cache">RedisCache</a> or a StackExchange <a href="https://stackexchange.github.io/StackExchange.Redis/">IConnectionMultiplexer</a> in an application running on Cloud Foundry.</p>
<p>In addition to the <a href="#5-1-quick-start">Quick Start</a>, other Steeltoe sample applications are available to help you understand how to use this connector:</p>
<ul>
<li><a href="https://github.com/SteeltoeOSS/Samples/tree/dev/Connectors/src/AspDotNet4/Redis4">AspDotNet4/Redis4</a>: Same as the next Quick Start but built for ASP.NET 4.x.</li>
<li><a href="https://github.com/SteeltoeOSS/Samples/tree/master/Security/src/RedisDataProtectionKeyStore">DataProtection</a>: A sample application showing how to use the Steeltoe DataProtection Key Storage Provider for Redis.</li>
<li><a href="https://github.com/SteeltoeOSS/Samples/tree/master/MusicStore">MusicStore</a>: A sample application showing how to use all of the Steeltoe components together in an ASP.NET Core application. This is a micro-services based application built from the ASP.NET Core reference app MusicStore provided by Microsoft.</li>
</ul>
<p>This connector provides a <code>IHealthContributor</code> which you can use in conjunction with the <a href="https://steeltoe.io/docs/steeltoe-management/#1-2-3-health">Steeltoe Management Health</a> check endpoint.  See the <a href="#using-health-contributors">Using Health Contributors</a> section for details on how to make use of it.</p>
<p>The source code for this connector can be found <a href="https://github.com/SteeltoeOSS/Connectors">here</a>.</p>
<h2 id="usage">Usage</h2>
<p>You should know how the .NET <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration service</a> works before starting to use the connector. To configure the connector, you need a basic understanding of the <code>ConfigurationBuilder</code> and how to add providers to the builder.</p>
<p>You should also know how the ASP.NET Core <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup">Startup</a> class is used in configuring the application services for the app. Pay particular attention to the usage of the <code>ConfigureServices()</code> method.</p>
<p>You probably want some understanding of how to use the <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed#using-a-redis-distributed-cache">RedisCache</a> or <a href="https://stackexchange.github.io/StackExchange.Redis/">IConnectionMultiplexer</a> before starting to use this connector.</p>
<p>To use this connector:</p>
<ol>
<li>Create a Redis Service instance and bind it to your application.</li>
<li>Optionally, configure any Redis client settings (for example, in <code>appsettings.json</code>).</li>
<li>Add the Steeltoe Cloud Foundry config provider to your ConfigurationBuilder.</li>
<li>Add DistributedRedisCache or ConnectionMultiplexer to your ServiceCollection.</li>
</ol>
<h3 id="add-nuget-reference">Add NuGet Reference</h3>
<p>To use the Redis connector, you need to add a reference to the appropriate <a href="#add-nuget-references">Steeltoe Connector NuGet package</a> and a reference to <code>Microsoft.Extensions.Caching.Redis</code>, <code>StackExchange.Redis</code>, or <code>StackExchange.Redis.StrongName</code>.</p>
<blockquote class="blockquote">
<p>NOTE: The requirement to add a direct Redis package reference is new as of version 2.0.0.</p>
</blockquote>
<!-- -->
<blockquote class="blockquote">
<p>NOTE: Because <code>Microsoft.Extensions.Caching.Redis</code> depends on <code>StackExchange.Redis.StrongName</code>, adding a reference to the Microsoft library also enables access to the StackExchange classes, as seen in the sample application.</p>
</blockquote>
<h3 id="configure-settings">Configure Settings</h3>
<p>The connector supports several settings for the Redis connection that can be useful when you are developing and testing an application locally and you need to have the connector configure the connection for non-default settings.</p>
<p>The following example of the connector's configuration in JSON that shows how to set up a connection to a Redis server at <code>https://foo.bar:1111</code>:</p>
<pre><code class="language-json">{
  ...
  &quot;redis&quot;: {
    &quot;client&quot;: {
      &quot;host&quot;: &quot;https://foo.bar&quot;,
      &quot;port&quot;: 1111
    }
  }
  ...
}
</code></pre>
<p>The following table table describes all possible settings for the connector</p>
<table class="table">
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>Hostname or IP Address of the server</td>
<td>localhost</td>
</tr>
<tr>
<td>port</td>
<td>Port number of the server</td>
<td>6379</td>
</tr>
<tr>
<td>endPoints</td>
<td>Comma-separated list of host:port pairs</td>
<td>not set</td>
</tr>
<tr>
<td>clientName</td>
<td>Identification for the connection within redis</td>
<td>not set</td>
</tr>
<tr>
<td>connectRetry</td>
<td>Times to repeat initial connect attempts</td>
<td>3</td>
</tr>
<tr>
<td>connectTimeout</td>
<td>Timeout (ms) for connect operations</td>
<td>5000</td>
</tr>
<tr>
<td>abortOnConnectFail</td>
<td>Will not create a connection while no servers are available</td>
<td>true</td>
</tr>
<tr>
<td>keepAlive</td>
<td>Time (seconds) at which to send a message to help keep sockets alive</td>
<td>-1</td>
</tr>
<tr>
<td>resolveDns</td>
<td>Whether DNS resolution should be explicit and eager, rather than implicit</td>
<td>false</td>
</tr>
<tr>
<td>ssl</td>
<td>Whether SSL encryption should be used</td>
<td>false</td>
</tr>
<tr>
<td>sslHost</td>
<td>Enforces a particular SSL host identity on the server's certificate</td>
<td>not set</td>
</tr>
<tr>
<td>writeBuffer</td>
<td>Size of the output buffer</td>
<td>4096</td>
</tr>
<tr>
<td>connectionString</td>
<td>Full connection string</td>
<td>built from settings</td>
</tr>
<tr>
<td>instanceId</td>
<td>Cache ID. Used only with <code>IDistributedCache</code></td>
<td>not set</td>
</tr>
<tr>
<td>urlEncodedCredentials</td>
<td>Set to <code>true</code> if your service broker provides URL-encoded credentials</td>
<td>false</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>IMPORTANT: All of these settings should be prefixed with <code>redis:client:</code>.</p>
</blockquote>
<p>The samples and most templates are already set up to read from <code>appsettings.json</code>See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<blockquote class="blockquote">
<p>NOTE: If a ConnectionString is provided and VCAP_SERVICES are not detected (a typical scenario for local app development), the ConnectionString will be used exactly as provided.</p>
</blockquote>
<h3 id="cloud-foundry">Cloud Foundry</h3>
<p>To use Redis on Cloud Foundry, create and bind an instance to your application by using the Cloud Foundry CLI, as shown in the following example:</p>
<pre><code class="language-bash"># Create Redis service
cf create-service p-redis shared-vm myRedisCache

# Bind service to `myApp`
cf bind-service myApp myRedisCache

# Restage the app to pick up change
cf restage myApp
</code></pre>
<blockquote class="blockquote">
<p>NOTE: The preceding commands assume you use the Redis service provided by Pivotal on Cloud Foundry. If you use a different service, you have to adjust the <code>create-service</code> command to fit your environment.</p>
</blockquote>
<p>Version 2.1.1+ of this connector works with the <a href="https://docs.pivotal.io/partners/azure-open-service-broker-pcf/index.html">Azure Open Service Broker for PCF</a>. Be sure to set <code>redis:client:urlEncodedCredentials</code> to <code>true</code> as this broker may provide credentials that have been URL Encoded.</p>
<p>Once the service is bound to your application, the connector's settings are available in <code>VCAP_SERVICES</code>. See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<h3 id="add-idistributedcache">Add IDistributedCache</h3>
<p>To use Microsoft's <code>IDistributedCache</code> in your application, add it to the service container, as shown in the following example:</p>
<pre><code class="language-csharp">using Steeltoe.CloudFoundry.Connector.Redis;
public class Startup {
   public IConfiguration Configuration { get; private set; }
   public Startup()
   {
   }
   public void ConfigureServices(IServiceCollection services)
   {
       // Add Microsoft Redis Cache (IDistributedCache) configured from Cloud Foundry
       services.AddDistributedRedisCache(Configuration);

       // Add framework services
       services.AddMvc();
   }
</code></pre>
<p>The <code>AddDistributedRedisCache(Configuration)</code> method call configures the <code>IDistributedCache</code> by using the configuration built by the application earlier and adds the connection to the service container.</p>
<h3 id="use-idistributedcache">Use IDistributedCache</h3>
<p>The following example shows how to inject and use the <code>IDistributedCache</code> in a controller once it has been added to the service container:</p>
<pre><code class="language-csharp">using Microsoft.Extensions.Caching.Distributed;
...
public class HomeController : Controller
{
    private IDistributedCache _cache;
    public HomeController(IDistributedCache cache)
    {
        _cache = cache;
    }
    ...
    public IActionResult CacheData()
    {
        string key1 = Encoding.Default.GetString(_cache.Get(&quot;Key1&quot;));
        string key2 = Encoding.Default.GetString(_cache.Get(&quot;Key2&quot;));

        ViewData[&quot;Key1&quot;] = key1;
        ViewData[&quot;Key2&quot;] = key2;

        return View();
    }
}
</code></pre>
<h3 id="add-iconnectionmultiplexer">Add IConnectionMultiplexer</h3>
<p>To use a StackExchange <code>IConnectionMultiplexer</code> in your application directly, add it to the service container in the <code>ConfigureServices()</code> method of the <code>Startup</code> class, as shown in the following example:</p>
<pre><code class="language-csharp">using Steeltoe.CloudFoundry.Connector.Redis;

public class Startup {
   ...
   public IConfiguration Configuration { get; private set; }
   public Startup(...)
   {
     ...
   }
   public void ConfigureServices(IServiceCollection services)
   {

       // Add StackExchange IConnectionMultiplexer configured from Cloud Foundry
       services.AddRedisConnectionMultiplexer(Configuration);

       // Add framework services
       services.AddMvc();
       ...
   }
   ...
</code></pre>
<p>The <code>AddRedisConnectionMultiplexer(Configuration)</code> method call configures the <code>IConnectionMultiplexer</code> by using the configuration built by the application and adds the connection to the service container.</p>
<blockquote class="blockquote">
<p>NOTE: If necessary, you can use both <code>IDistributedCache</code> and <code>IConnectionMultiplexer</code> in your application.</p>
</blockquote>
<h3 id="use-iconnectionmultiplexer">Use IConnectionMultiplexer</h3>
<p>Once you have configured and added the <code>IConnectionMultiplexer</code> to the service container, you can inject it and use it in a controller or a view, as shown in the following example:</p>
<pre><code class="language-csharp">using Microsoft.Extensions.Caching.Distributed;
...
public class HomeController : Controller
{
    private IConnectionMultiplexer _conn;
    public HomeController(IConnectionMultiplexer conn)
    {
        _conn = conn;
    }
    ...
     public IActionResult ConnData()
   {
       IDatabase db = _conn.GetDatabase();

       string key1 = db.StringGet(&quot;ConnectionMultiplexerKey1&quot;);
       string key2 = db.StringGet(&quot;ConnectionMultiplexerKey2&quot;);

       ViewData[&quot;ConnectionMultiplexerKey1&quot;] = key1;
       ViewData[&quot;ConnectionMultiplexerKey2&quot;] = key2;

       return View();
   }
}
</code></pre>
