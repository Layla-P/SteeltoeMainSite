<h1 id="single-sign-on-with-openid-connect">Single Sign-on with OpenID Connect</h1>
<p>Single Sign-on with OpenID Connect enables you to leverage existing credentials configured in a <a href="https://github.com/cloudfoundry/uaa">UAA Server</a> or <a href="https://docs.pivotal.io/p-identity">Pivotal Single Sign-on service</a> for authentication and authorization in ASP.NET 4.x (via OWIN middleware) and ASP.NET Core applications.</p>
<p>The source code for this provider can be found <a href="https://github.com/SteeltoeOSS/Security">here</a>.</p>
<h2 id="usage">Usage</h2>
<h3 id="usage-in-asp.net-core">Usage in ASP.NET Core</h3>
<p>Steeltoe builds on top of <code>Microsoft.AspNetCore.Authentication.OpenIdConnect</code>. You may benefit from reading more about using <a href="https://andrewlock.net/an-introduction-to-openid-connect-in-asp-net-core/">OpenID Connect in ASP.NET Core</a>.</p>
<p>Usage of Steeltoe's OpenID Connect provider is effectively identical to that of the <a href="#1-2-usage">OAuth2 provider</a>, although the behind-the-scenes story is a little different. The OpenID Connect provider uses Microsoft's OpenId Connect implementation, and settings are based on <code>Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectOptions</code>, with these additional properties:</p>
<table class="table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>additionalScopes</td>
<td>Scopes to request for tokens in addition to <code>openid</code></td>
<td><code>string.Empty</code></td>
</tr>
<tr>
<td>validateCertificates</td>
<td>Validate Auth server certificate</td>
<td><code>true</code></td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: <strong>Each setting above must be prefixed with <code>security:oauth2:client</code></strong>.</p>
<p>Aside from the different base class for options, the only usage change is to call <code>.AddCloudFoundryOpenId</code> instead of <code>.AddCloudFoundryOAuth</code>.</p>
<h3 id="usage-in-asp.net-4.x">Usage in ASP.NET 4.x</h3>
<p>This package is built on OpenID Connect and OWIN Middleware. You should take some time to understand both before proceeding to use this provider.</p>
<p>Resources are available elsewhere for understanding OpenID Connect. For example, see <a href="https://blog.runscope.com/posts/understanding-oauth-2-and-openid-connect">Understanding OAuth 2.0 and OpenID Connect</a>.</p>
<p>To learn more about OWIN, start with the <a href="https://docs.microsoft.com/en-us/aspnet/aspnet/overview/owin-and-katana/an-overview-of-project-katana">Overview of Project Katana</a>.</p>
<p>Additionally, you should know how the .NET <a href="https://docs.asp.net/en/latest/fundamentals/configuration.html">Configuration service</a> and the <code>ConfigurationBuilder</code> work and how to add providers to the builder.</p>
<p>With regard to Cloud Foundry, you should know how Cloud Foundry OAuth security services (for example, <a href="https://github.com/cloudfoundry/uaa">UAA Server</a> or <a href="https://docs.pivotal.io/p-identity/">Pivotal Single Signon</a>) work.</p>
<p>In order to use the Security provider:</p>
<ol>
<li>Create an instance of a Cloud Foundry OAuth service and bind it to your application.</li>
<li>(Optional) Configure any additional settings the Security provider needs.</li>
<li>Add the Cloud Foundry configuration provider to the <code>ConfigurationBuilder</code>.</li>
<li>Add the security provider to the OWIN pipeline in the application.</li>
<li>Secure your endpoints.</li>
</ol>
<h4 id="add-nuget-reference">Add NuGet Reference</h4>
<p>To use the provider, use the NuGet package manager to add a reference to the <code>Steeltoe.Security.Authentication.CloudFoundryOwin</code> package.</p>
<h4 id="configure-settings">Configure Settings</h4>
<p>Configuring settings for the provider beyond what is provided in a service binding is not typically required, but when Cloud Foundry is using self-signed certificates, you might need to disable certificate validation, as shown in the following example:</p>
<pre><code class="language-json">{
  &quot;security&quot;: {
    &quot;oauth2&quot;: {
      &quot;client&quot;: {
        &quot;validateCertificates&quot;: false
      }
    }
  }
}
</code></pre>
<p>The samples and most templates are already set up to read from <code>appsettings.json</code>. See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<p>This full list of settings can also be configured, though <code>AuthDomain</code>, <code>ClientId</code> and <code>ClientSecret</code> will be overridden by service bindings (if present).</p>
<table class="table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>additionalScopes</td>
<td>Scopes to request for tokens in addition to <code>openid</code></td>
<td><code>string.Empty</code></td>
</tr>
<tr>
<td>authDomain</td>
<td>Location of the OAuth2 server</td>
<td><code>https://Default_OAuthServiceUrl</code></td>
</tr>
<tr>
<td>authenticationType</td>
<td>Corresponds to the IIdentity AuthenticationType</td>
<td><code>CloudFoundry</code></td>
</tr>
<tr>
<td>callbackPath</td>
<td>Path the user is redirected back to after authentication</td>
<td><code>/signin-cloudfoundry</code></td>
</tr>
<tr>
<td>clientId</td>
<td>App credentials with auth server</td>
<td><code>Default_ClientId</code></td>
</tr>
<tr>
<td>clientSecret</td>
<td>App credentials with auth server</td>
<td><code>Default_ClientSecret</code></td>
</tr>
<tr>
<td>validateCertificates</td>
<td>Validate OAuth2 server certificate</td>
<td><code>true</code></td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: <strong>Each setting above must be prefixed with <code>security:oauth2:client</code></strong>.</p>
<blockquote class="blockquote">
<p>NOTE: Prior to Steeltoe 2.2, the default value for CallbackPath was <code>/signin-oidc</code></p>
</blockquote>
<h4 id="cloud-foundry">Cloud Foundry</h4>
<p>As mentioned earlier, there are two ways to use OAuth2 services on Cloud Foundry. We recommend you read the offical documentation (<a href="https://github.com/cloudfoundry/uaa">UAA Server</a> and <a href="https://docs.pivotal.io/p-identity/1-5/getting-started.html">Pivotal SSO</a>) or follow the instructions included in the samples for <a href="https://github.com/SteeltoeOSS/Samples/blob/master/Security/src/AspDotNet4/CloudFoundrySingleSignon/README.md">UAA Server</a> and <a href="https://github.com/SteeltoeOSS/Samples/blob/master/Security/src/AspDotNet4/CloudFoundrySingleSignon/README-SSO.md">Pivotal SSO</a> to quickly learn how to create and bind OAuth2 services.</p>
<p>Regardless of which provider you choose, once the service is bound to your application, the settings are available in <code>VCAP_SERVICES</code>. See <a href="#reading-configuration-values">Reading Configuration Values</a>.</p>
<h4 id="configure-owin-startup">Configure OWIN Startup</h4>
<p>In order to configure the Cloud Foundry OWIN OAuth provider in your application, you will need an <a href="https://docs.microsoft.com/en-us/aspnet/aspnet/overview/owin-and-katana/owin-startup-class-detection">OWIN Startup class</a> if you do not already have one.</p>
<pre><code class="language-csharp">using Steeltoe.Security.Authentication.CloudFoundry.Owin;
using System;
using System.IdentityModel.Claims;
using System.Linq;
using System.Web.Helpers;

[assembly: OwinStartup(typeof(CloudFoundrySingleSignon.Startup))]

namespace CloudFoundrySingleSignon
{
    public partial class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            app.SetDefaultSignInAsAuthenticationType(&quot;ExternalCookie&quot;);
            app.UseCookieAuthentication(new CookieAuthenticationOptions
            {
                AuthenticationType = &quot;ExternalCookie&quot;,
                AuthenticationMode = AuthenticationMode.Active,
                CookieName = &quot;.AspNet.ExternalCookie&quot;,
                LoginPath = new PathString(&quot;/Account/AuthorizeSSO&quot;),
                ExpireTimeSpan = TimeSpan.FromMinutes(5)
            });

            app.UseCloudFoundryOpenIdConnect(ApplicationConfig.Configuration);

            AntiForgeryConfig.UniqueClaimTypeIdentifier = ClaimTypes.NameIdentifier;
        }
    }
}
</code></pre>
<p>The <code>app.UseCloudFoundryOpenIdConnect</code> method call adds an authentication middleware that has been configured to work with UAA or Pivotal SSO to the OWIN Request pipeline.</p>
<blockquote class="blockquote">
<p>TIP: This code is commonly refactored into a separate class (for example <code>Startup.Auth.cs</code>), particularly when there is additional configuration on the OWIN pipeline.</p>
</blockquote>
<h4 id="redirecting-to-oauth-server">Redirecting to OAuth Server</h4>
<p>To redirect the user to the OAuth server for authentication, invoke <code>IAuthenticationManager.Challenge</code>, specifying a redirect uri (for the user to land on after authentication) and the string value configured as the authentication type.</p>
<p>In Steeltoe 2.2 and up, the default value for AuthenticationType is <code>CloudFoundryDefaults.DisplayName</code> or &quot;CloudFoundry&quot;. Prior to Steeltoe 2.2, this value was <code>PivotalSSO</code> and was not configureable. The now-deprecated extension <code>.UseOpenIDConnect()</code> still uses that as the default, but can be overridden in <code>OpenIDConnectOptions</code>.</p>
<pre><code class="language-csharp">public void AuthorizeSSO(string returnUrl)
{
    var properties = new AuthenticationProperties { RedirectUri = returnUrl ?? Url.Action(&quot;Secure&quot;, &quot;Home&quot;) };
    HttpContext.GetOwinContext().Authentication.Challenge(properties, CloudFoundryDefaults.DisplayName);
}
</code></pre>
<blockquote class="blockquote">
<p>NOTE: The second parameter passed to <code>Authentication.Challenge</code> <em>must</em> match the authentication type used to configure the provider; this is the piece that hands the flow over to Steeltoe.</p>
</blockquote>
<p>If you wish to allow your controller action to return <code>ActionResult</code> instead of void, refactor the call to <code>Challenge</code> into a class that inherits <code>HttpUnauthorizedResult</code> such as this</p>
<pre><code class="language-csharp">internal class ChallengeResult : HttpUnauthorizedResult
{
    public ChallengeResult(string authType, string redirectUri)
    {
        AuthenticationType = authType;
        RedirectUri = redirectUri;
    }

    public string AuthenticationType { get; set; }

    public string RedirectUri { get; set; }

    public override void ExecuteResult(ControllerContext context)
    {
        var properties = new AuthenticationProperties { RedirectUri = RedirectUri };
        context.HttpContext.GetOwinContext().Authentication.Challenge(properties, AuthenticationType);
    }
}
</code></pre>
<p>The updated controller code would then look like this:</p>
<pre><code class="language-csharp">public ActionResult AuthorizeSSO(string returnUrl)
{
    return new ChallengeResult(CloudFoundryDefaults.DisplayName, returnUrl ?? Url.Action(&quot;Secure&quot;, &quot;Home&quot;));
}
</code></pre>
<h4 id="securing-endpoints">Securing Endpoints</h4>
<p>Once the <code>Startup</code> class is in place and the middleware is configured, you can use the standard ASP.NET <code>Authorize</code> attribute to require authentication, as shown in the following example:</p>
<pre><code class="language-csharp">using System.Web.Mvc;
...
public class HomeController : Controller
{
    public ActionResult Index()
    {
        return View();
    }

    [Authorize]
    public ActionResult Secure()
    {
        ViewData[&quot;Message&quot;] = &quot;This page requires authentication&quot;;
        return View();
    }
    ...
}
</code></pre>
<p>Requiring claims is not built into the framework, so it is not quite as simple as in ASP.NET Core, but is still possible in a variety of ways. The Steeltoe SSO sample demonstrates extending the <a href="https://github.com/IdentityModel/Thinktecture.IdentityModel.45/blob/master/IdentityModel/Thinktecture.IdentityModel/Authorization/MVC/ClaimsAuthorizeAttribute.cs">Thinktecture ClaimsAuthorizeAttribute</a> with a <a href="https://github.com/SteeltoeOSS/Samples/blob/dev/Security/src/AspDotNet4/CloudFoundrySingleSignon/CustomClaimsAuthorizeAttribute.cs">CustomClaimsAuthorizeAttribute</a> to redirect to an &quot;Access Denied&quot; page when a user is authenticated but lacks the required claim. Using either of those attributes is straightforward, as shown in this example:</p>
<pre><code class="language-csharp">// When using this attribute, an authenticated user who does not have the claim will be redirected to the login page
[ClaimsAuthorize(&quot;testgroup&quot;)]
public ActionResult TestGroupV1()
{
    ViewBag.Message = &quot;Congratulations, you have access to 'testgroup'&quot;;
    return View(&quot;Index&quot;);
}

[CustomClaimsAuthorize(&quot;testgroup&quot;)]
public ActionResult TestGroupV2()
{
    ViewBag.Message = &quot;Congratulations, you have access to 'testgroup'&quot;;
    return View(&quot;Index&quot;);
}
</code></pre>
