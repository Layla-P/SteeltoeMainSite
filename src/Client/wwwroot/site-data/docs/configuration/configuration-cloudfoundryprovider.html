<h1 id="cloud-foundry-provider">Cloud Foundry Provider</h1>
<p>The Cloud Foundry provider enables the standard Cloud Foundry environment variables (<code>VCAP_APPLICATION</code>,  <code>VCAP_SERVICES</code>, and <code>CF_*</code>) to be parsed and accessed as configuration data within a .NET application.</p>
<p>Cloud Foundry creates and uses these environment variables to communicate an application's environment and configuration to the application code running inside a container. More specifically, the values found in <code>VCAP_APPLICATION</code> provide information about the application's resource limits, routes (URIs), and version number, among other things. The <code>VCAP_SERVICES</code> environment variable provides information about the external services (Databases, Caches, and so on) to which the application is bound, along with details on how to contact those services.</p>
<p>You can read more information on the Cloud Foundry environment variables at the <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html">Cloud Foundry docs</a> website.</p>
<p>The Steeltoe Cloud Foundry provider supports the following .NET application types:</p>
<ul>
<li>ASP.NET (MVC, WebForms, WebAPI, WCF)</li>
<li>ASP.NET Core</li>
<li>Console apps (.NET Framework and .NET Core)</li>
</ul>
<p>The source code for this provider can be found <a href="https://github.com/SteeltoeOSS/Configuration">here</a>.</p>
<h2 id="usage">Usage</h2>
<p>The following sections describe how to use the Cloud Foundry configuration provider:</p>
<ul>
<li><a href="#1-2-1-add-nuget-reference">Add NuGet Reference</a></li>
<li><a href="#1-2-2-add-configuration-provider">Add Configuration Provider</a></li>
<li><a href="#1-2-3-access-configuration-data">Access Configuration Data</a></li>
<li><a href="#1-2-4-access-configuration-data-as-options">Access Configuration Data as Options</a></li>
</ul>
<p>You should have a good understanding of how the .NET <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration services</a> work before starting to use this provider.</p>
<p>In order to use the Steeltoe Cloud Foundry provider you need to do the following:</p>
<ol>
<li>Add a NuGet package reference to your project.</li>
<li>Add the provider to the Configuration Builder.</li>
<li>Configure Cloud Foundry options classes by binding configuration data to the classes.</li>
<li>Inject and use the Cloud Foundry Options to access Cloud Foundry configuration data.</li>
</ol>
<blockquote class="blockquote">
<p>NOTE: Most of the example code in the following sections is based on using Steeltoe in an ASP.NET Core application. If you are developing an ASP.NET 4.x application or a Console based app, see the <a href="https://github.com/SteeltoeOSS/Samples/tree/master/Configuration">other samples</a> for example code you can use.</p>
</blockquote>
<h3 id="add-nuget-reference">Add NuGet Reference</h3>
<p>To use the provider, you need to add a reference to the appropriate Steeltoe Cloud Foundry NuGet based on the type of the application you are building and what Dependency Injector you have chosen, if any. The following table describes the available packages:</p>
<table class="table">
<thead>
<tr>
<th>App Type</th>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Console/ASP.NET 4.x</td>
<td><code>Steeltoe.Extensions.Configuration.CloudFoundryBase</code></td>
<td>Base functionality. No dependency injection.</td>
</tr>
<tr>
<td>ASP.NET Core</td>
<td><code>Steeltoe.Extensions.Configuration.CloudFoundryCore</code></td>
<td>Includes base. Adds ASP.NET Core dependency injection.</td>
</tr>
<tr>
<td>ASP.NET 4.x with Autofac</td>
<td><code>Steeltoe.Extensions.Configuration.CloudFoundryAutofac</code></td>
<td>Includes base. Adds Autofac dependency injection.</td>
</tr>
</tbody>
</table>
<p>To add this type of NuGet to your project, add a <code>PackageReference</code> resembling the following:</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
...
    &lt;PackageReference Include=&quot;Steeltoe.Extensions.Configuration.CloudFoundryCore&quot; Version= &quot;2.1.0&quot;/&gt;
...
&lt;/ItemGroup&gt;
</code></pre>
<h3 id="add-configuration-provider">Add Configuration Provider</h3>
<p>In order to parse the Cloud Foundry environment variables and make them available in the application's configuration, you need to add the Cloud Foundry configuration provider to the <code>ConfigurationBuilder</code>.</p>
<p>The following example shows how to do so:</p>
<pre><code class="language-csharp">using Steeltoe.Extensions.Configuration;
...

var builder = new ConfigurationBuilder()
    .SetBasePath(env.ContentRootPath)
    .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
    .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true)

    // Add VCAP_* configuration data
    .AddCloudFoundry();
Configuration = builder.Build();
...

</code></pre>
<p>When developing a .NET Core application, you can do the same thing by using the <code>AddCloudFoundry()</code> extension method for either the <code>IWebHostBuilder</code> or Generic <code>IHostBuilder</code>. The following example shows how to do so:</p>
<pre><code class="language-csharp">public class Program
{
    public static void Main(string[] args)
    {
        BuildWebHost(args).Run();
    }
    public static IWebHost BuildWebHost(string[] args) =&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseCloudFoundryHosting()

            // Add VCAP_* configuration data
            .AddCloudFoundry()
            .UseStartup&lt;Startup&gt;()
            .Build();
}
</code></pre>
<h3 id="access-configuration-data">Access Configuration Data</h3>
<p>Once the configuration has been built, the values from the <code>VCAP_APPLICATION</code> and <code>VCAP_SERVICES</code> environment variables have been added to the application's configuration data and become available under keys prefixed with <code>vcap:application</code> and <code>vcap:services</code> respectively.</p>
<p>You can access the values from the <code>VCAP_APPLICATION</code> environment variable settings directly from the configuration as follows:</p>
<pre><code class="language-csharp">var config = builder.Build();
var appName = config[&quot;vcap:application:application_name&quot;]
var instanceId = config[&quot;vcap:application:instance_id&quot;]
...
</code></pre>
<p>A list of all <code>VCAP_APPLICATION</code> keys is available in the <a href="https://docs.CloudFoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-APPLICATION">VCAP_APPLICATION</a> topic of the Cloud Foundry documentation.</p>
<p>You can also directly access the values from the <code>VCAP_SERVICES</code> environment variable. For example, to access the information about the first instance of a bound Cloud Foundry service with a name of <code>service-name</code>, you could code the following:</p>
<pre><code class="language-csharp">var config = builder.Build();
var name = config[&quot;vcap:services:service-name:0:name&quot;]
var uri = config[&quot;vcap:services:service-name:0:credentials:uri&quot;]
...
</code></pre>
<p>A list of all <code>VCAP_SERVICES</code> keys is available in the <a href="https://docs.CloudFoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES">VCAP_SERVICES</a> topic of the Cloud Foundry documentation.</p>
<blockquote class="blockquote">
<p>NOTE: This provider uses the built-in .NET <a href="https://github.com/aspnet/Configuration/tree/dev/src/Microsoft.Extensions.Configuration.Json">JSON Configuration Parser</a> when parsing the JSON provided in the <code>VCAP_*</code> environment variables. As a result, you can expect the exact same key names and behavior as you see when parsing JSON configuration files (such as <code>appsettings.json</code>) in your application.</p>
</blockquote>
<h3 id="access-configuration-data-as-options">Access Configuration Data as Options</h3>
<h4 id="configurecloudfoundryoptions">ConfigureCloudFoundryOptions()</h4>
<p>Alternatively, instead of accessing the Cloud Foundry configuration data directly from the configuration, you can use the .NET <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Options</a> framework together with <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">Dependency Injection</a>.</p>
<p>The Cloud Foundry provider includes two additional classes, <code>CloudFoundryApplicationOptions</code> and <code>CloudFoundryServicesOptions</code>. Both can be configured through the Options framework to hold the parsed <code>VCAP_*</code> data by using the Options <code>Configure()</code> feature.</p>
<p>To use it in an ASP.NET Core application, add the the following to the <code>ConfigureServices()</code> method in the <code>Startup</code> class:</p>
<pre><code class="language-csharp">using Steeltoe.Extensions.Configuration.CloudFoundry;

public void ConfigureServices(IServiceCollection services)
{
    // Setup Options framework with DI
    services.AddOptions();

    // Add Steeltoe Cloud Foundry Options to service container
    services.ConfigureCloudFoundryOptions(Configuration);
}
</code></pre>
<p>The <code>ConfigureCloudFoundryOptions(Configuration)</code> method call uses the Options framework to bind the <code>vcap:application</code> configuration values to an instance of <code>CloudFoundryApplicationOptions</code> and binds the <code>vcap:services</code> values to an instance of <code>CloudFoundryServicesOptions</code>.</p>
<p>Both of these method calls also add these objects to the service container as <code>IOptions</code>.</p>
<p>Once this is done, you can access these configuration objects in the Controllers or Views of an application by using normal Dependency Injection.</p>
<p>The following example controller shows how to do so:</p>
<pre><code class="language-csharp">using Steeltoe.Extensions.Configuration.CloudFoundry;

public class HomeController : Controller
{
    public HomeController(IOptions&lt;CloudFoundryApplicationOptions&gt; appOptions,
                            IOptions&lt;CloudFoundryServicesOptions&gt; serviceOptions)
    {
        AppOptions = appOptions.Value;
        ServiceOptions = serviceOptions.Value;
    }

    CloudFoundryApplicationOptions AppOptions { get; private set; }
    CloudFoundryServicesOptions ServiceOptions { get; private set; }

    // GET: /&lt;controller&gt;/
    public IActionResult Index()
    {
        ViewData[&quot;AppName&quot;] = AppOptions.ApplicationName;
        ViewData[&quot;AppId&quot;] = AppOptions.ApplicationId;
        ViewData[&quot;URI-0&quot;] = AppOptions.ApplicationUris[0];

        ViewData[ServiceOptions.ServicesList[0].Label] = ServiceOptions.ServicesList[0].Name;
        ViewData[&quot;client_id&quot;]= ServiceOptions.ServicesList[0].Credentials[&quot;client_id&quot;].Value;
        ViewData[&quot;client_secret&quot;]= ServiceOptions.ServicesList[0].Credentials[&quot;client_secret&quot;].Value;
        ViewData[&quot;uri&quot;]= ServiceOptions.ServicesList[0].Credentials[&quot;uri&quot;].Value;
        return View();
    }
}
</code></pre>
<h4 id="configurecloudfoundryservice">ConfigureCloudFoundryService</h4>
<p>As an alternative to using <code>CloudFoundryServicesOptions</code> to access Cloud Foundry service data you can also use <code>ConfigureCloudFoundryService&lt;TOption&gt;()</code> or <code>ConfigureCloudFoundryServices&lt;TOption&gt;()</code> to easily gain access to service data.</p>
<p>These methods allow you to define an Option class which represents a particular type of Cloud Foundry service binding and then use either method to select that data from <code>VCAP_SERVICES</code> and bind the data to it.</p>
<p>To do this, you first need to create a Options class that derives from <code>AbstractServiceOptions</code>. That class must match the data provided in <code>VCAP_SERVICES</code>.</p>
<p>Here is an example that illustrates how to do this for a MySql service binding on PCF:</p>
<pre><code class="language-csharp">using Steeltoe.Extensions.Configuration.CloudFoundry;

public class MySqlServiceOption : AbstractServiceOptions
{
    public MySqlServiceOption() { }
    public MySqlCredentials Credentials { get; set; }
}

public class MySqlCredentials
{
    public string Hostname { get; set; }
    public int Port { get; set; }
    public string Name { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public string Uri { get; set; }
    public string JdbcUrl { get; set; }
}
</code></pre>
<p>Next in your <code>Startup</code> class you can use either <code>ConfigureCloudFoundryService&lt;TOption&gt;()</code> or <code>ConfigureCloudFoundryServices&lt;TOption&gt;()</code> to bind the service data from <code>VCAP_SERVICES</code> to your <code>TOption</code>.  There are multiple ways to do this depending on your needs.</p>
<p>You can use <code>ConfigureCloudFoundryService&lt;TOption&gt;()</code> method to select a specific Cloud Foundry service binding from <code>VCAP_SERVICES</code> by specifying a service name. Or you can use <code>ConfigureCloudFoundryServices&lt;TOption&gt;()</code> to bind to all services of a particular type by specifying a Cloud Foundry service label.</p>
<p>Here are some examples:</p>
<pre><code class="language-csharp">using Steeltoe.Extensions.Configuration.CloudFoundry;

public void ConfigureServices(IServiceCollection services)
{
    // Setup Options framework with DI
    services.AddOptions();

    // Bind VCAP_SERVICES data for mySql2 service instance to MySqlServiceOption
    services.ConfigureCloudFoundryService&lt;MySqlServiceOption&gt;(Configuration, &quot;mySql2&quot;);

    // Bind VCAP_SERVICES data for all p-mysql service instances to MySqlServiceOption
    services.ConfigureCloudFoundryServices&lt;MySqlServiceOption&gt;(Configuration, &quot;p-mysql&quot;);
}
</code></pre>
<p>As you can see all of this is built using the Microsoft provided Options framework.  As a result we are able to leverage the <code>named</code> Options feature Microsoft has implemented in options binding, and configure each <code>TOption</code> with a name equal to the Cloud Foundry service name found in <code>VCAP_SERVICES</code>.</p>
<p>What this means is within a controller you can inject the <code>IOptionsSnapshot&lt;MySqlServiceOption&gt;</code> or <code>IOptionsMonitor&lt;MySqlServiceOption&gt;</code> as you normally would and then access the Option by name. (for example: specific Cloud Foundry service binding instance).</p>
<p>Here is an example:</p>
<pre><code class="language-csharp">    public class HomeController : Controller
    {
        private IOptionsSnapshot&lt;MySqlServiceOption&gt; _mySqlOptions;
        private  MySqlServiceOption MySqlOptions
        {
            get
            {
                return _mySqlOptions.Get(&quot;mySql2&quot;);
            }
        }

        public HomeController(IOptionsSnapshot&lt;MySqlServiceOption&gt; mySqlOptions)
        {
            _mySqlOptions = mySqlOptions;
        }
</code></pre>
