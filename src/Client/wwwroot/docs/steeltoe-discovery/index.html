<!DOCTYPE html>
<!-- saved from url=(0048) -->
<html class="gr__steeltoe_io">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta content="IE=edge" http-equiv="X-UA-Compatible">

	<meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

	<!-- Use title if it's in the page YAML frontmatter -->
	<link href="images/favicon.png" rel="icon" type="image/png">
	<link rel="stylesheet" href="/stylesheets/css.css">
	<link href="/stylesheets/site.css" rel="stylesheet">
	<link href="/stylesheets/tocbot.css" rel="stylesheet">
</head>

<body class="docs docs_steeltoe-discovery docs_steeltoe-discovery_index" data-gr-c-s-loaded="true">

	<div class="max-width-4 mx-auto">
		<div class="">
			<div class="sm-flex">
				<div class="col-12 sm-col-3 sm-pr3">
					
					<div id="toc" class="">
						
						<div class="toc-link border-bottom border-silver js-toc"><ul class="toc-list "><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#0-0-initialize-dev-environment" class="toc-link node-name--H1  is-active-link">0.0 Initialize Dev Environment</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-0-steeltoe-discovery" class="toc-link node-name--H1 ">1.0 Steeltoe Discovery</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-1-add-nuget-references" class="toc-link node-name--H2 ">1.1 Add NuGet References</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-initialize-discovery-client" class="toc-link node-name--H2 ">1.2 Initialize Discovery Client</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-1-asp-net-core" class="toc-link node-name--H3 ">1.2.1 ASP.NET Core</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-2-asp-net" class="toc-link node-name--H3 ">1.2.2 ASP.NET</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-3-registering-services" class="toc-link node-name--H3 ">1.2.3 Registering Services</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-3-discovering-services" class="toc-link node-name--H2 ">1.3 Discovering Services</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-3-1-discoveryhttpclienthandler" class="toc-link node-name--H3 ">1.3.1 DiscoveryHttpClientHandler</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-3-2-using-httpclientfactory" class="toc-link node-name--H3 ">1.3.2 Using HttpClientFactory</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-3-3-using-idiscoveryclient" class="toc-link node-name--H3 ">1.3.3 Using IDiscoveryClient</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-load-balancing" class="toc-link node-name--H2 ">1.4 Load Balancing</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-1-iloadbalancer" class="toc-link node-name--H3 ">1.4.1 ILoadBalancer</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-2-random-load-balancer" class="toc-link node-name--H3 ">1.4.2 Random Load Balancer</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-2-1-using-httpclientfactory" class="toc-link node-name--H4 ">1.4.2.1 Using HttpClientFactory</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-2-2-using-an-httpclienthandler" class="toc-link node-name--H4 ">1.4.2.2 Using an HttpClientHandler</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-3-round-robin-load-balancer" class="toc-link node-name--H3 ">1.4.3 Round Robin Load Balancer</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-3-1-using-with-httpclientfactory" class="toc-link node-name--H4 ">1.4.3.1 Using with HttpClientFactory</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-3-2-using-an-httpclienthandler" class="toc-link node-name--H4 ">1.4.3.2 Using an HttpClientHandler</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-4-custom-iloadbalancer" class="toc-link node-name--H3 ">1.4.4 Custom ILoadBalancer</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-4-1-usage-with-httpclientfactory" class="toc-link node-name--H4 ">1.4.4.1 Usage with HttpClientFactory</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-4-2-using-an-httpclienthandler" class="toc-link node-name--H4 ">1.4.4.2 Using an HttpClientHandler</a></li></ul></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#1-5-enable-logging" class="toc-link node-name--H2 ">1.5 Enable Logging</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-0-netflix-eureka" class="toc-link node-name--H1 ">2.0 Netflix Eureka</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-quick-start" class="toc-link node-name--H2 ">2.1 Quick Start</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-running-locally" class="toc-link node-name--H3 ">2.1.1 Running Locally</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-1-start-eureka-server" class="toc-link node-name--H4 ">2.1.1.1 Start Eureka Server</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-2-locate-sample" class="toc-link node-name--H4 ">2.1.1.2 Locate Sample</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-3-run-fortune-teller" class="toc-link node-name--H4 ">2.1.1.3 Run Fortune Teller</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-4-observe-logs" class="toc-link node-name--H4 ">2.1.1.4 Observe Logs</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-1-5-view-fortunes" class="toc-link node-name--H4 ">2.1.1.5 View Fortunes</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-running-on-cloud-foundry" class="toc-link node-name--H3 ">2.1.2 Running on Cloud Foundry</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-1-start-eureka-server" class="toc-link node-name--H4 ">2.1.2.1 Start Eureka Server</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-2-publish-both-applications" class="toc-link node-name--H4 ">2.1.2.2 Publish Both Applications</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-3-push-both-applications" class="toc-link node-name--H4 ">2.1.2.3 Push Both Applications</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-4-observe-logs" class="toc-link node-name--H4 ">2.1.2.4 Observe Logs</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-2-5-view-fortunes" class="toc-link node-name--H4 ">2.1.2.5 View Fortunes</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-1-3-understanding-the-sample" class="toc-link node-name--H3 ">2.1.3 Understanding the Sample</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-usage" class="toc-link node-name--H2 ">2.2 Usage</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-1-eureka-settings" class="toc-link node-name--H3 ">2.2.1 Eureka Settings</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-1-1-settings-to-fetch-registry" class="toc-link node-name--H4 ">2.2.1.1 Settings to Fetch Registry</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-1-2-settings-to-register-services" class="toc-link node-name--H4 ">2.2.1.2 Settings to Register Services</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-2-bind-to-cloud-foundry" class="toc-link node-name--H3 ">2.2.2 Bind to Cloud Foundry</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-3-enable-logging" class="toc-link node-name--H3 ">2.2.3 Enable Logging</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-4-configuring-health-contributors" class="toc-link node-name--H3 ">2.2.4 Configuring Health Contributors</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-5-configuring-health-checks" class="toc-link node-name--H3 ">2.2.5 Configuring Health Checks</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-6-configuring-multiple-serviceurls" class="toc-link node-name--H3 ">2.2.6 Configuring Multiple ServiceUrls</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-7-configuring-metadata" class="toc-link node-name--H3 ">2.2.7 Configuring Metadata</a></li></ul></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-0-hashicorp-consul" class="toc-link node-name--H1 ">3.0 HashiCorp Consul</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-quick-start" class="toc-link node-name--H2 ">3.1 Quick Start</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-running-locally" class="toc-link node-name--H3 ">3.1.1 Running Locally</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-1-start-consul-server" class="toc-link node-name--H4 ">3.1.1.1 Start Consul Server</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-2-locate-and-config-sample" class="toc-link node-name--H4 ">3.1.1.2 Locate and Config Sample</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-3-run-fortune-teller" class="toc-link node-name--H4 ">3.1.1.3 Run Fortune Teller</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-4-observe-logs" class="toc-link node-name--H4 ">3.1.1.4 Observe Logs</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-1-5-view-fortunes" class="toc-link node-name--H4 ">3.1.1.5 View Fortunes</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-1-2-understanding-the-sample" class="toc-link node-name--H3 ">3.1.2 Understanding the Sample</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-usage" class="toc-link node-name--H2 ">3.2 Usage</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-1-consul-settings" class="toc-link node-name--H3 ">3.2.1 Consul Settings</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-2-enable-logging" class="toc-link node-name--H3 ">3.2.2 Enable Logging</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-3-health-contributor" class="toc-link node-name--H3 ">3.2.3 Health Contributor</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-4-configuring-health-check" class="toc-link node-name--H3 ">3.2.4 Configuring Health Check</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-5-configuring-metadata" class="toc-link node-name--H3 ">3.2.5 Configuring Metadata</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-6-configuring-instanceid" class="toc-link node-name--H3 ">3.2.6 Configuring InstanceId</a></li></ul></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#common-steps" class="toc-link node-name--H1 ">Common Steps</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#publish-sample" class="toc-link node-name--H2 ">Publish Sample</a><ul class="toc-list  is-collapsible is-collapsed"><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#asp-net-core" class="toc-link node-name--H3 ">ASP.NET Core</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#asp-net-4-x" class="toc-link node-name--H3 ">ASP.NET 4.x</a></li></ul></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#push-sample" class="toc-link node-name--H2 ">Push Sample</a></li><li class="toc-list-item"><a href="https://steeltoe.io/docs/steeltoe-discovery/#reading-configuration-values" class="toc-link node-name--H2 ">Reading Configuration Values</a></li></ul></li></ul></div>
					</div>
				</div>
				<div class="col-12 sm-col-9 js-toc-content">

					<h1 id="1-0-steeltoe-discovery">1.0 Steeltoe Discovery</h1>

					<p>Steeltoe provides a set of generalized interfaces for interacting with multiple service discovery back ends. This section will cover the general components first. If you are looking for something specific to the registry server you are using, feel free to skip ahead to the section for <a href="https://steeltoe.io/docs/steeltoe-discovery/#2-0-netflix-eureka">Netflix Eureka</a> or <a href="https://steeltoe.io/docs/steeltoe-discovery/#3-0-hashicorp-consul">HashiCorp Consul</a>.</p>

					<p>In order to use any Steeltoe Discovery client, you need to do the following:</p>

					<ul>
						<li>Add appropriate NuGet package reference to your project.</li>
						<li>Configure the settings the Discovery client will use to register services in the service registry.</li>
						<li>Configure the settings the Discovery client will use to discover services in the service registry.</li>
						<li>Add and Use the Discovery client service in the application.</li>
						<li>Use an injected <code>IDiscoveryClient</code> to lookup services.</li>
					</ul>

					<blockquote>
						<p>NOTE: The Steeltoe Discovery implementation (for example: the decision between Eureka and Consul) is automatically setup within the application based on the application configuration provided.</p>

						<p>IMPORTANT: The <code>Pivotal.Discovery.*</code> packages have been deprecated in Steeltoe 2.2 and will be removed in a future release.  All functionality provided in those packages has been pushed into the corresponding <code>Steeltoe.Discovery.*</code> packages.</p>
					</blockquote>

					<h2 id="1-1-add-nuget-references">1.1 Add NuGet References</h2>

					<!-- TODO: review this section, its not completely correct -->

					<p>The simplest way to get started with Steeltoe Discovery is to add a reference to a package built for either Microsoft’s dependency injection or Autofac. Either package will also include all relevant dependencies. If you are using another DI tool, please file an issue to let us know, and in the mean time use the relevant base package:</p>

					<table>
						<thead>
							<tr>
								<th>App Type</th>
								<th>Package</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>ASP.NET Core</td>
								<td><code>Steeltoe.Discovery.ClientCore</code></td>
								<td>Includes base. Adds ASP.NET Core dependency injection.</td>
							</tr>
							<tr>
								<td>ASP.NET 4.x with Autofac</td>
								<td><code>Steeltoe.Discovery.ClientAutofac</code></td>
								<td>Includes base. Adds Autofac dependency injection.</td>
							</tr>
							<tr>
								<td>Console/ASP.NET 4.x</td>
								<td><code>Steeltoe.Discovery.EurekaBase</code></td>
								<td>Base Eureka functionality. No dependency injection.</td>
							</tr>
							<tr>
								<td>Console/ASP.NET 4.x</td>
								<td><code>Steeltoe.Discovery.ConsulBase</code></td>
								<td>Base Consul functionality. No dependency injection.</td>
							</tr>
						</tbody>
					</table>

					<p>To add this type of NuGet to your project, add an element resembling the following <code>PackageReference</code>:</p>

<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
...
	<span class="hljs-tag">&lt;<span class="hljs-name">PackageReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"Steeltoe.Discovery.ClientCore"</span> <span class="hljs-attr">Version</span>= <span class="hljs-string">"2.3.0"</span>/&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
</code></pre>

					<h2 id="1-2-initialize-discovery-client">1.2 Initialize Discovery Client</h2>

					<h3 id="1-2-1-asp-net-core">1.2.1 ASP.NET Core</h3>

					<!-- TODO: rewrite this section to account for Pivotal packages going away, mention Autofac -->

					<p>The next step is to add the Steeltoe Discovery client to the service container and use it to cause the client to start communicating with the server.</p>

					<p>You do these two things in the <code>ConfigureServices()</code> and <code>Configure()</code> methods of the <code>Startup</code> class, as shown in the following example:</p>

<pre><code class="csharp hljs"><span class="hljs-keyword">using</span> Pivotal.Discovery.Client;
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">using</span> Steeltoe.Discovery.Client;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Startup</span> {
...
	<span class="hljs-keyword">public</span> IConfiguration Configuration { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Startup</span>(<span class="hljs-params">...</span>)
</span>{
  ...
}
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)
</span>{
		<span class="hljs-comment">// Add Steeltoe Discovery Client service</span>
  services.AddDiscoveryClient(Configuration);

		<span class="hljs-comment">// Add framework services.</span>
  services.AddMvc();
  ...
}
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">IApplicationBuilder app, ...</span>)
</span>{
  ...
  app.UseStaticFiles();
  app.UseMvc();

		<span class="hljs-comment">// Use the Steeltoe Discovery Client service</span>
  app.UseDiscoveryClient();
}
...
</code></pre>

					<blockquote>
						<p>NOTE: If you use the <code>Pivotal.Discovery.ClientCore</code> package, you need to add a <code>using Pivotal.Discovery.Client;</code>.  If you use the <code>Steeltoe.Discovery.ClientCore</code>, you need to add a <code>Steeltoe.Discovery.Client;</code>. Doing so is required to gain access to the extension methods described later.</p>
					</blockquote>

					<h3 id="1-2-2-asp-net">1.2.2 ASP.NET</h3>

					<!-- TODO -->

					<h3 id="1-2-3-registering-services">1.2.3 Registering Services</h3>

					<p>If you configured the clients settings to register services, the service is automatically registered when the <code>UseDiscoveryClient()</code> method is called in the <code>Configure()</code> method. You do not need to do anything else to cause service registration.</p>

					<p>See the <a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-2-eureka-client-settings">Eureka Client Settings</a> or <a href="https://steeltoe.io/docs/steeltoe-discovery/#3-0-hashicorp-consul">Consul Client Settings</a></p>

					<h2 id="1-3-discovering-services">1.3 Discovering Services</h2>

					<p>Depending on which Discovery service technology (e.g. Eureka or Consul) you are using the behavior of the client differs.</p>

					<p>With Eureka, once the app starts, the client begins to operate in the background, both registering and renewing service registrations and also periodically fetching the service registry from the server.</p>

					<p>With Consul, once the app starts, the client registers any services if required and if configured starts a health thread to keep updating the health of the service registration.  No service registrations are fetched by the Consul client until you ask to lookup a service. At that point a request is made of the Consul server.   As a result, you will probably want to use the Steeltoe caching load balancer with the Consul service discovery.</p>

					<h3 id="1-3-1-discoveryhttpclienthandler">1.3.1 DiscoveryHttpClientHandler</h3>

					<p>A simple way to use the registry to lookup services is to use the Steeltoe <code>DiscoveryHttpClientHandler</code> with <code>HttpClient</code>.</p>

					<p>This <code>FortuneService</code> class retrieves fortunes from the Fortune microservice, which is registered under a name of <code>fortuneService</code>:</p>

<pre><code class="csharp hljs"><span class="hljs-keyword">using</span> Pivotal.Discovery.Client;
<span class="hljs-comment">// or</span>
<span class="hljs-comment">// using Steeltoe.Discovery.Client;</span>

...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FortuneService</span> : <span class="hljs-title">IFortuneService</span>
{
    DiscoveryHttpClientHandler _handler;
					<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> RANDOM_FORTUNE_URL = <span class="hljs-string">"https://fortuneService/api/fortunes/random"</span>;
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FortuneService</span>(<span class="hljs-params">IDiscoveryClient client</span>)
    </span>{
        _handler = <span class="hljs-keyword">new</span> DiscoveryHttpClientHandler(client);
    }
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">RandomFortuneAsync</span>(<span class="hljs-params"></span>)
    </span>{
					<span class="hljs-keyword">var</span> client = GetClient();
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetStringAsync(RANDOM_FORTUNE_URL);
    }
					<span class="hljs-function"><span class="hljs-keyword">private</span> HttpClient <span class="hljs-title">GetClient</span>(<span class="hljs-params"></span>)
    </span>{
					<span class="hljs-comment">// WARNING: do NOT create a new HttpClient for every request in your code</span>
					<span class="hljs-comment">// -- you may experience socket exhaustion if you do!</span>
					<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> HttpClient(_handler, <span class="hljs-literal">false</span>);
					<span class="hljs-keyword">return</span> client;
    }
}
</code></pre>

					<p>First, notice that the <code>FortuneService</code> constructor takes an <code>IDiscoveryClient</code> as a parameter. This is Steeltoe’s interface for finding services in the service registry. The <code>IDiscoveryClient</code> implementation is registered with the service container for use in any controller, view, or service <a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-initialize-discovery-client">during initialization</a>. The constructor code for this class uses the client to create an instance of Steeltoe’s <code>DiscoveryHttpClientHandler</code>.</p>

					<p>Next, notice that when the <code>RandomFortuneAsync()</code> method is called, the <code>HttpClient</code> is created with the Steeltoe handler. The handler’s role is to intercept any requests made with the <code>HttpClient</code> and to evaluate the URL to see if the host portion of the URL can be resolved from the service registry. In this example, the <code>fortuneService</code> name should be resolved into an actual <code>host:port</code> before letting the request continue.</p>

					<p>If the name cannot be resolved, the handler ignores the request URL and lets the request continue unchanged.</p>

					<blockquote>
						<p>NOTE: <code>DiscoveryHttpClientHandler</code> performs random load balancing by default. That is, if there are multiple instances registered under a particular service name, the handler randomly selects one of those instances each time the handler is invoked. For more information, see the section on <a href="https://steeltoe.io/docs/steeltoe-discovery/#1-4-load-balancing">load balancing</a></p>
					</blockquote>

					<h3 id="1-3-2-using-httpclientfactory">1.3.2 Using HttpClientFactory</h3>

					<p>In addition to the <code>DiscoveryHttpClientHandler</code> mentioned above, you also have the option to use the new <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests">HttpClientFactory</a> together with the Steeltoe provided <code>DiscoveryHttpMessageHandler</code> for service lookup.</p>

					<p><code>DiscoveryHttpMessageHandler</code> is a <code>DelegatingHandler</code> that can be used, much like the <code>DiscoveryHttpClientHandler</code>, to intercept requests and to evaluate the URL to see if the host portion of the URL can be resolved from the current service registry.  The handler will do this for any <code>HttpClient</code> created by the factory.</p>

					<p>After <a href="https://steeltoe.io/docs/steeltoe-discovery/#1-2-initialize-discovery-client">initializing the discovery client</a>, you can easily configure <code>HttpClient</code>:</p>

<pre><code class="csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Startup</span>
{
    ...
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)
    </span>{
      ...
					<span class="hljs-comment">// Add Steeltoe handler to container (this line can be omitted when using Steeltoe versions &gt;= 2.2.0)</span>
      services.AddTransient&lt;DiscoveryHttpMessageHandler&gt;();

					<span class="hljs-comment">// Configure HttpClient</span>
      services.AddHttpClient(<span class="hljs-string">"fortunes"</span>, c =&gt;
      {
        c.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"https://fortuneService/api/fortunes/"</span>);
      })
      .AddHttpMessageHandler&lt;DiscoveryHttpMessageHandler&gt;()
      .AddTypedClient&lt;IFortuneService, FortuneService&gt;();
      ...
    }
    ...
}
</code></pre>

					<p>The updated version of <code>FortuneService</code> is a bit simpler:</p>

<pre><code class="csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FortuneService</span> : <span class="hljs-title">IFortuneService</span>
{
					<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> RANDOM_FORTUNE_URL = <span class="hljs-string">"https://fortuneService/api/fortunes/random"</span>;
					<span class="hljs-keyword">private</span> HttpClient _client;
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FortuneService</span>(<span class="hljs-params">HttpClient client</span>)
    </span>{
        _client = client;
    }
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">RandomFortuneAsync</span>(<span class="hljs-params"></span>)
    </span>{
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _client.GetStringAsync(RANDOM_FORTUNE_URL);
    }
}
</code></pre>

					<p>Check out the Microsoft documentation on <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests">HttpClientFactory</a> to see all the various ways you can make use of message handlers.</p>

					<blockquote>
						<p>NOTE: <code>DiscoveryHttpMessageHandler</code> has an optional <code>ILoadBalancer</code> parameter. If no <code>ILoadBalancer</code> is provided via dependency injection, a <code>RandomLoadBalancer</code> is used. To change this behavior, add an <code>ILoadBalancer</code> to the DI container or use a load-balancer first configuration as described within section 1.4 on this page.</p>
					</blockquote>

					<h3 id="1-3-3-using-idiscoveryclient">1.3.3 Using IDiscoveryClient</h3>

					<p>In the event the handler options don’t serve your needs, you can always make lookup requests directly on the <code>IDiscoveryClient</code> interface.</p>

					<p>These methods available on an <code>IDiscoveryClient</code> provide access to services and service instances available in the registry:</p>

<pre><code class="csharp hljs"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Gets all known service Ids</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
IList&lt;<span class="hljs-keyword">string</span>&gt; Services { <span class="hljs-keyword">get</span>; }

<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Get all ServiceInstances associated with a particular serviceId</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="serviceId"&gt;</span>the serviceId to lookup<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>List of service instances<span class="hljs-doctag">&lt;/returns&gt;</span></span>
<span class="hljs-function">IList&lt;IServiceInstance&gt; <span class="hljs-title">GetInstances</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> serviceId</span>)</span>;
</code></pre>

					<h2 id="1-4-load-balancing">1.4 Load Balancing</h2>

					<p>Any time a client needs to select a service instance to send a request to, some mechanism is required for selecting the instance to call. In all mechanisms provided for service discovery in Steeltoe versions before 2.2.0, service instances were selected randomly. <code>Steeltoe.Common</code> 2.2.0 added a new abstraction named <code>ILoadBalancer</code>, which provides configurable load balancing.</p>

					<h3 id="1-4-1-iloadbalancer">1.4.1 ILoadBalancer</h3>

					<p>The <code>ILoadBalancer</code> interface defines two methods:</p>

<pre><code class="csharp hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILoadBalancer</span>
  {
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> Evaluates a Uri for a host name that can be resolved into a service instance</span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="request"&gt;</span>A Uri containing a service name that can be resolved into one or more service instances<span class="hljs-doctag">&lt;/param&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>The original Uri, with serviceName replaced by the host:port of a service instance<span class="hljs-doctag">&lt;/returns&gt;</span></span>
					<span class="hljs-function">Task&lt;Uri&gt; <span class="hljs-title">ResolveServiceInstanceAsync</span>(<span class="hljs-params">Uri request</span>)</span>;

					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> A mechanism for tracking statistics for service instances</span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="originalUri"&gt;</span>The original request Uri<span class="hljs-doctag">&lt;/param&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="resolvedUri"&gt;</span>The Uri resolved by the load balancer<span class="hljs-doctag">&lt;/param&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="responseTime"&gt;</span>The amount of time taken for a remote call to complete<span class="hljs-doctag">&lt;/param&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name="exception"&gt;</span>Any exception called during calls to a resolved service instance<span class="hljs-doctag">&lt;/param&gt;</span></span>
					<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task<span class="hljs-doctag">&lt;/returns&gt;</span></span>
					<span class="hljs-function">Task <span class="hljs-title">UpdateStatsAsync</span>(<span class="hljs-params">Uri originalUri, Uri resolvedUri, TimeSpan responseTime, Exception exception</span>)</span>;
  }
</code></pre>

					<p>Any implementation of <code>ILoadBalancer</code> is expected to know how to interact with some form of service discovery mechanism. The included load balancers expect an <code>IServiceInstanceProvider</code> to be available in the DI service container, so they still require configuration of Eureka, Consul or some other mechanism for providing service instances.</p>

					<h3 id="1-4-2-random-load-balancer">1.4.2 Random Load Balancer</h3>

					<p>The <code>RandomLoadBalancer</code>, as the name implies, randomly selects a service instance from all instances that are resolved from a given service name. The <code>ILoadBalancer</code> implementation adds the (optional) ability to cache service instance data, which is useful for <code>IServiceInstanceProvider</code> or <code>IDiscoveryClient</code> implementations that do not provide their own caching (such as the Consul provider). Service instance data caching happens automatically if an <code>IDistributedCache</code> instance is provided via constructor injection.</p>

					<blockquote>
						<p>NOTE: <code>RandomLoadBalancer</code> does not track stats or exceptions. <code>UpdateStatsAsync</code> simply returns <code>Task.CompletedTask</code></p>
					</blockquote>

					<h4 id="1-4-2-1-using-httpclientfactory">1.4.2.1 Using HttpClientFactory</h4>

					<p>To add a service registry-backed random load balancer to an <code>HttpClient</code> constructed using <code>HttpClientFactory</code>, you may use the <code>AddRandomLoadBalancer()</code> extension:</p>

<pre><code class="csharp hljs">  services.AddHttpClient(<span class="hljs-string">"fortunes"</span>)
      .AddRandomLoadBalancer()
</code></pre>

					<blockquote>
						<p>NOTE: This is functionally equivalent to using the default behavior of the <code>DiscoveryHttpMessageHandler</code>, as described <a href="https://steeltoe.io/docs/steeltoe-discovery/#1-3-2-using-httpclientfactory">above</a></p>
					</blockquote>

					<h4 id="1-4-2-2-using-an-httpclienthandler">1.4.2.2 Using an HttpClientHandler</h4>

					<p>The random load balancer can be used with the included <code>HttpClientHandler</code> that works with any <code>ILoadBalancer</code>:</p>

<pre><code class="csharp hljs">  <span class="hljs-keyword">private</span> HttpClient _httpClient;
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FortuneService</span>(<span class="hljs-params">IDiscoveryClient discoveryClient</span>)
  </span>{
					<span class="hljs-keyword">var</span> loadBalancer = <span class="hljs-keyword">new</span> RandomLoadBalancer(discoveryClient);
					<span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> LoadBalancerHttpClientHandler(loadBalancer);
      _httpClient = <span class="hljs-keyword">new</span> HttpClient(handler);
  }
</code></pre>

					<h3 id="1-4-3-round-robin-load-balancer">1.4.3 Round Robin Load Balancer</h3>

					<p>The provided round robin load balancer sends traffic to service instances in sequential order, as they are provided by the <code>IServiceInstanceProvider</code>. Like the <code>RandomLoadBalancer</code>, the <code>RoundRobinLoadBalancer</code> also includes the (optional) ability to cache service instances if an <code>IDistributedCache</code> instance is provided via constructor injection. Additionally, when a provided <code>IDistributedCache</code> instance is shared amongst clients (for example: using a shared Redis cache for multiple front-end application instances) the round robin sequence tracking will be shared across clients, ensuring an even load distribution.</p>

					<blockquote>
						<p>NOTE: <code>RoundRobinLoadBalancer</code> does not track stats or exceptions. <code>UpdateStatsAsync</code> simply returns <code>Task.CompletedTask</code></p>
					</blockquote>

					<h4 id="1-4-3-1-using-with-httpclientfactory">1.4.3.1 Using with HttpClientFactory</h4>

					<p>To add a service registry-backed round robin load balancer to an <code>HttpClient</code>, you may use the <code>AddRoundRobinLoadBalancer()</code> extension. This example also adds a Redis cache so that regardless of which client service instance makes the call, backend service instances will be called in round robin order:</p>

<pre><code class="csharp hljs">  services.AddDistributedRedisCache(Configuration);
  services.AddHttpClient(<span class="hljs-string">"fortunes"</span>)
      .AddRoundRobinLoadBalancer()
</code></pre>

					<h4 id="1-4-3-2-using-an-httpclienthandler">1.4.3.2 Using an HttpClientHandler</h4>

					<p>The round robin load balancer can be used with the included <code>HttpClientHandler</code> that works with any <code>ILoadBalancer</code>:</p>

<pre><code class="csharp hljs">  <span class="hljs-keyword">private</span> HttpClient _httpClient;
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FortuneService</span>(<span class="hljs-params">IDiscoveryClient discoveryClient</span>)
  </span>{
					<span class="hljs-keyword">var</span> loadBalancer = <span class="hljs-keyword">new</span> RoundRobinLoadBalancer(discoveryClient);
					<span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> LoadBalancerHttpClientHandler(loadBalancer);
      _httpClient = <span class="hljs-keyword">new</span> HttpClient(handler);
  }
</code></pre>

					<h3 id="1-4-4-custom-iloadbalancer">1.4.4 Custom ILoadBalancer</h3>

					<p>If the provided load balancer implementations don’t suit your needs, you are free to create your own implementation of <code>ILoadBalancer</code>.</p>

					<p>This example shows a load balancer that would always return the first listed instance, no matter what:</p>

<pre><code class="csharp hljs">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IServiceInstanceProvider _serviceInstanceProvider;

					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FirstInstanceLoadBalancer</span>(<span class="hljs-params">IServiceInstanceProvider serviceInstanceProvider</span>)
  </span>{
      _serviceInstanceProvider = serviceInstanceProvider;
  }

					<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;Uri&gt; <span class="hljs-title">ResolveServiceInstanceAsync</span>(<span class="hljs-params">Uri request</span>)
  </span>{
					<span class="hljs-keyword">var</span> availableServiceInstances = _serviceInstanceProvider.GetInstances(request.Host);
					<span class="hljs-keyword">return</span> Task.FromResult(<span class="hljs-keyword">new</span> Uri(availableServiceInstances[<span class="hljs-number">0</span>].Uri, request.PathAndQuery));
  }

					<span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">UpdateStatsAsync</span>(<span class="hljs-params">Uri originalUri, Uri resolvedUri, TimeSpan responseTime, Exception exception</span>)
  </span>{
					<span class="hljs-keyword">return</span> Task.CompletedTask;
  }
</code></pre>

					<h4 id="1-4-4-1-usage-with-httpclientfactory">1.4.4.1 Usage with HttpClientFactory</h4>

					<p>Custom load balancers can be added to the HttpClient pipeline with an included generic extension:</p>

<pre><code class="csharp hljs">    services.AddHttpClient(<span class="hljs-string">"fortunes"</span>)
        .AddLoadBalancer&lt;RandomLoadBalancer&gt;()
</code></pre>

					<p>With this model, a <code>LoadBalancerDelegatingHandler</code> will expect an <code>ILoadBalancer</code> to be provided via dependency injection, so be sure to add yours to the DI container.</p>

					<h4 id="1-4-4-2-using-an-httpclienthandler">1.4.4.2 Using an HttpClientHandler</h4>

					<p>Additionally, your custom load balancer can also be used with the included <code>HttpClientHandler</code>. Create an instance of your load balancer, pass it to a <code>LoadBalancerHttpClientHandler</code> and create an <code>HttpClient</code> that uses that handler:</p>

<pre><code class="csharp hljs">  <span class="hljs-keyword">private</span> HttpClient _httpClient;
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FortuneService</span>(<span class="hljs-params">IDiscoveryClient discoveryClient</span>)
  </span>{
					<span class="hljs-keyword">var</span> loadBalancer = <span class="hljs-keyword">new</span> FirstInstanceLoadBalancer(discoveryClient);
					<span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">new</span> LoadBalancerHttpClientHandler(loadBalancer);
      _httpClient = <span class="hljs-keyword">new</span> HttpClient(handler);
  }
</code></pre>

					<h2 id="1-5-enable-logging">1.5 Enable Logging</h2>

					<p>Sometimes, it is desirable to turn on debug logging in the Discovery client. To do so, you can modify the <code>appsettings.json</code> file and turn on Debug level logging for the Steeltoe/Pivotal components, as shown in the following example:</p>

					<p>Here is an example <code>appsettings.json</code> file:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"Logging"</span>: {
					<span class="hljs-attr">"IncludeScopes"</span>: <span class="hljs-literal">false</span>,
					<span class="hljs-attr">"LogLevel"</span>: {
					<span class="hljs-attr">"Default"</span>: <span class="hljs-string">"Warning"</span>,
					<span class="hljs-attr">"Pivotal"</span>: <span class="hljs-string">"Debug"</span>,
					<span class="hljs-attr">"Steeltoe"</span>: <span class="hljs-string">"Debug"</span>
    }
  },
  ...
}
</code></pre>

					<h1 id="2-0-netflix-eureka">2.0 Netflix Eureka</h1>
					<p>The following sections describe how to use the Eureka client.</p>

					<ul>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-1-eureka-settings">Eureka Settings</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-2-bind-to-cloud-foundry">Bind to Cloud Foundry</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-3-enable-logging">Enable Logging</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-4-configuring-health-contributors">Configuring Health Contributors</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-5-configuring-health-checks">Configuring Health Checks</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-6-configuring-multiple-serviceurls">Configuring Multiple ServiceUrls</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#2-2-7-configuring-metadata">Configuring Metadata</a></li>
					</ul>

					<p>You should know how the new .NET <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration service</a> works before starting to use the client. A basic understanding of the <code>ConfigurationBuilder</code> and how to add providers to the builder is necessary in order to configure the client.</p>

					<p>You should also know how the ASP.NET Core <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup">Startup</a> class is used in configuring the application services and the middleware used in the app. Pay particular attention to the usage of the <code>Configure()</code> and <code>ConfigureServices()</code> methods.</p>

					<p>You should also have a good understanding of the <a target="_blank" href="https://projects.spring.io/spring-cloud/">Spring Cloud Eureka Server</a>.</p>

					<p>In order to use the Steeltoe Discovery client, you need to do the following:</p>

					<ul>
						<li>Add appropriate NuGet package reference to your project.</li>
						<li>Configure the settings the Discovery client will use to register services in the service registry.</li>
						<li>Configure the settings the Discovery client will use to discover services in the service registry.</li>
						<li>Add and Use the Discovery client service in the application.</li>
						<li>Use an injected <code>IDiscoveryClient</code> to lookup services.</li>
					</ul>

					<blockquote>
						<p>NOTE: Most of the example code in the following sections is based on using Discovery in a ASP.NET Core application. If you are developing a ASP.NET 4.x application or a console-based app, see the <a target="_blank" href="https://github.com/SteeltoeOSS/Samples/tree/master/Discovery">other samples</a> for example code you can use.</p>
					</blockquote>

					<h3 id="2-2-1-eureka-settings">2.2.1 Eureka Settings</h3>

					<p>To get the Steeltoe Discovery client to properly communicate with the Eureka server, you need to provide a few configuration settings to the client.</p>

					<p>What you provide depends on whether you want your application to register a service and whether it also needs to discover services with which to communicate.</p>

					<p>General settings that control the behavior of the client are found under the prefix with a key of <code>eureka:client</code>. Settings that affect registering services are found under the <code>eureka:instance</code> prefix.</p>

					<p>The following table describes the settings that control the overall behavior of the client:</p>

					<p>All of these settings should start with <code>eureka:client:</code></p>

					<table>
						<thead>
							<tr>
								<th>Key</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>shouldRegisterWithEureka</td>
								<td>Enable or disable registering as a service</td>
								<td>true</td>
							</tr>
							<tr>
								<td>shouldFetchRegistry</td>
								<td>Enable or disable discovering services</td>
								<td>true</td>
							</tr>
							<tr>
								<td>shouldGZipContent</td>
								<td>Enable or disable GZip usage between client and Eureka server</td>
								<td>true</td>
							</tr>
							<tr>
								<td>serviceUrl</td>
								<td>Comma delimited list of Eureka server endpoints</td>
								<td><code>http://localhost:8761/eureka</code></td>
							</tr>
							<tr>
								<td>validateCertificates</td>
								<td>Enable or disable certificate validation</td>
								<td>true</td>
							</tr>
							<tr>
								<td>registryFetchIntervalSeconds</td>
								<td>Service fetch interval</td>
								<td>30s</td>
							</tr>
							<tr>
								<td>shouldFilterOnlyUpInstances</td>
								<td>Whether to fetch only UP instances</td>
								<td>true</td>
							</tr>
							<tr>
								<td>instanceInfoReplicationIntervalSeconds</td>
								<td>How often to replicate instance changes</td>
								<td>40s</td>
							</tr>
							<tr>
								<td>shouldDisableDelta</td>
								<td>Whether to disable fetching of delta and, instead, get the full registry</td>
								<td>false</td>
							</tr>
							<tr>
								<td>registryRefreshSingleVipAddress</td>
								<td>Whether to be interested in only the registry information for a single VIP</td>
								<td>none</td>
							</tr>
							<tr>
								<td>shouldOnDemandUpdateStatusChange</td>
								<td>Whether status updates are trigger on-demand register/update</td>
								<td>true</td>
							</tr>
							<tr>
								<td>accessTokenUri</td>
								<td>URI to use to obtain OAuth2 access token</td>
								<td>none</td>
							</tr>
							<tr>
								<td>clientSecret</td>
								<td>Secret to use to obtain OAuth2 access token</td>
								<td>none</td>
							</tr>
							<tr>
								<td>clientId</td>
								<td>Client ID to use to obtain OAuth2 access token</td>
								<td>none</td>
							</tr>
							<tr>
								<td>eurekaServer:proxyHost</td>
								<td>Proxy host to Eureka Server</td>
								<td>none</td>
							</tr>
							<tr>
								<td>eurekaServer:proxyPort</td>
								<td>Proxy port to Eureka Server</td>
								<td>none</td>
							</tr>
							<tr>
								<td>eurekaServer:proxyUserName</td>
								<td>Proxy user name to Eureka Server</td>
								<td>none</td>
							</tr>
							<tr>
								<td>eurekaServer:proxyPassword</td>
								<td>Proxy password to Eureka Server</td>
								<td>none</td>
							</tr>
							<tr>
								<td>eurekaServer:shouldGZipContent</td>
								<td>Whether to compress content</td>
								<td>true</td>
							</tr>
							<tr>
								<td>eurekaServer:connectTimeoutSeconds</td>
								<td>Connection timeout</td>
								<td>5s</td>
							</tr>
							<tr>
								<td>eurekaServer:retryCount</td>
								<td>Number of times to retry Eureka Server requests</td>
								<td>3</td>
							</tr>
							<tr>
								<td>health:enabled</td>
								<td>Enable or disable management health contributor</td>
								<td>true</td>
							</tr>
							<tr>
								<td>health:checkEnabled</td>
								<td>Enable or disable Eureka health check handler</td>
								<td>true</td>
							</tr>
							<tr>
								<td>health:monitoredApps</td>
								<td>List apps the management health contributor monitors</td>
								<td>All apps in registry</td>
							</tr>
						</tbody>
					</table>

					<p><strong>NOTE</strong>: <strong>Some settings above affect registering as a service as well.</strong></p>

					<p>The following table describes the settings you can use to configure the behavior of the client as it relates to registering services:</p>

					<table>
						<thead>
							<tr>
								<th>Key</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>appName</td>
								<td>Name of the application to be registered with Eureka</td>
								<td>‘spring:application:name’ or ‘unknown’</td>
							</tr>
							<tr>
								<td>port</td>
								<td>Port on which the instance is registered</td>
								<td>80</td>
							</tr>
							<tr>
								<td>hostName</td>
								<td>Address on which the instance is registered</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>instanceId</td>
								<td>Unique ID (within the scope of the <code>appName</code>) of the instance registered with Eureka</td>
								<td><code>computed</code></td>
							</tr>
							<tr>
								<td>appGroupName</td>
								<td>Name of the application group to be registered with Eureka</td>
								<td>none</td>
							</tr>
							<tr>
								<td>instanceEnabledOnInit</td>
								<td>Whether the instance should take traffic as soon as it is registered</td>
								<td>false</td>
							</tr>
							<tr>
								<td>securePort</td>
								<td>Secure port on which the instance should receive traffic</td>
								<td>443</td>
							</tr>
							<tr>
								<td>nonSecurePortEnabled</td>
								<td>Non-secure port enabled for traffic</td>
								<td>true</td>
							</tr>
							<tr>
								<td>securePortEnabled</td>
								<td>Secure port enabled for traffic</td>
								<td>false</td>
							</tr>
							<tr>
								<td>leaseRenewalIntervalInSeconds</td>
								<td>How often client needs to send heartbeats</td>
								<td>30s</td>
							</tr>
							<tr>
								<td>leaseExpirationDurationInSeconds</td>
								<td>Time the Eureka server waits before removing instance</td>
								<td>90s</td>
							</tr>
							<tr>
								<td>vipAddress</td>
								<td>Virtual host name</td>
								<td>hostName + port</td>
							</tr>
							<tr>
								<td>secureVipAddress</td>
								<td>Secure virtual host name</td>
								<td>hostName + securePort</td>
							</tr>
							<tr>
								<td>metadataMap</td>
								<td>Name/value pairs associated with the instance</td>
								<td>none</td>
							</tr>
							<tr>
								<td>statusPageUrlPath</td>
								<td>Relative status page path for this instance</td>
								<td><code>/Status</code></td>
							</tr>
							<tr>
								<td>statusPageUrl</td>
								<td>Absolute status page for this instance</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>homePageUrlPath</td>
								<td></td>
								<td><code>/</code></td>
							</tr>
							<tr>
								<td>homePageUrl</td>
								<td>Absolute home page for this instance</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>healthCheckUrlPath</td>
								<td></td>
								<td><code>/healthcheck</code></td>
							</tr>
							<tr>
								<td>healthCheckUrl</td>
								<td>Absolute health check page for this instance</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>secureHealthCheckUrl</td>
								<td>Secured absolute health check page for this instance</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>ipAddress</td>
								<td>IP address to register</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>preferIpAddress</td>
								<td>Whether to register by using IpAddress instead of hostname</td>
								<td>false</td>
							</tr>
							<tr>
								<td>registrationMethod</td>
								<td>How to register service on Cloud Foundry. Can be <code>route</code>, <code>direct</code>, or <code>hostname</code></td>
								<td><code>route</code></td>
							</tr>
						</tbody>
					</table>

					<p>All of the settings in the preceding table should start with <code>eureka:instance:</code>.</p>

					<p>You should register by using the <code>direct</code> setting mentioned earlier when you want to use container-to-container networking on Cloud Foundry. You should use the <code>hostname</code> setting on Cloud Foundry when you want the registration to use whatever value is configured or computed as <code>eureka:instance:hostName</code>.</p>

					<p>For a complete understanding of the effects of many of these settings, we recommend that you review the documentation on the <a target="_blank" href="https://github.com/Netflix/eureka/wiki">Netflix Eureka Wiki</a>. In most cases, unless you are confident you understand the effects of changing the values from their defaults, we recommend that you use the defaults.</p>

					<h4 id="2-2-1-1-settings-to-fetch-registry">2.2.1.1 Settings to Fetch Registry</h4>

					<p>The following example shows the clients settings in JSON that are necessary to cause the client to fetch the service registry from the server at an address of <code>http://localhost:8761/eureka/</code>:</p>

<pre><code class="json hljs">{
<span class="hljs-attr">"spring"</span>: {
					<span class="hljs-attr">"application"</span>: {
					<span class="hljs-attr">"name"</span>: <span class="hljs-string">"fortuneUI"</span>
    }
  },
					<span class="hljs-attr">"eureka"</span>: {
					<span class="hljs-attr">"client"</span>: {
					<span class="hljs-attr">"serviceUrl"</span>: <span class="hljs-string">"http://localhost:8761/eureka/"</span>,
					<span class="hljs-attr">"shouldRegisterWithEureka"</span>: <span class="hljs-literal">false</span>
    }
  }
  ...
}
</code></pre>

					<p>The <code>eureka:client:shouldRegisterWithEureka</code> instructs the client to NOT register any services in the registry, as the application does not offer any services (that is, it only wants to discover).</p>

					<blockquote>
						<p>NOTE: If you use self-signed certificates on Cloud Foundry, you might run into SSL certificate validation issues when pushing apps. A quick way to work around this is to disable certificate validation until a proper solution can be put in place.</p>
					</blockquote>

					<h4 id="2-2-1-2-settings-to-register-services">2.2.1.2 Settings to Register Services</h4>

					<p>The following example shows the clients settings in JSON that are necessary to cause the client to register a service named <code>fortuneService</code> with a Eureka Server at an address of <code>http://localhost:8761/eureka/</code>:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"spring"</span>: {
					<span class="hljs-attr">"application"</span>: {
					<span class="hljs-attr">"name"</span>:  <span class="hljs-string">"fortuneService"</span>
    }
  },
					<span class="hljs-attr">"eureka"</span>: {
					<span class="hljs-attr">"client"</span>: {
					<span class="hljs-attr">"serviceUrl"</span>: <span class="hljs-string">"http://localhost:8761/eureka/"</span>,
					<span class="hljs-attr">"shouldFetchRegistry"</span>: <span class="hljs-literal">false</span>
    },
					<span class="hljs-attr">"instance"</span>: {
					<span class="hljs-attr">"port"</span>: <span class="hljs-number">5000</span>
    }
  }
  ...
}
</code></pre>

					<p>The <code>eureka:instance:port</code> setting is the port on which the service is registered. The hostName portion is determined automatically at runtime. The <code>eureka:client:shouldFetchRegistry</code> setting instructs the client NOT to fetch the registry as the app does not need to discover services. It only wants to register a service. The default for the <code>shouldFetchRegistry</code> setting is true.</p>

					<p>The samples and most templates are already set up to read from <code>appsettings.json</code>. See <a href="https://steeltoe.io/docs/steeltoe-discovery/#reading-configuration-values">Reading Configuration Values</a> for more information about reading configuration values.</p>

					<h3 id="2-2-2-bind-to-cloud-foundry">2.2.2 Bind to Cloud Foundry</h3>

					<p>When you want to use a Eureka Server on Cloud Foundry and you have installed <a target="_blank" href="https://docs.pivotal.io/spring-cloud-services/1-5/common/index.html">Spring Cloud Services</a>, you can create and bind a instance of the server to the application by using the Cloud Foundry CLI, as follows:</p>

<pre><code class="bash hljs"><span class="hljs-comment"># Create eureka server instance named `myDiscoveryService`</span>
cf create-service p-service-registry standard myDiscoveryService

<span class="hljs-comment"># Wait for service to become ready</span>
cf services

<span class="hljs-comment"># Bind the service to `myApp`</span>
cf <span class="hljs-built_in">bind</span>-service myApp myDiscoveryService

<span class="hljs-comment"># Restage the app to pick up change</span>
cf restage myApp
</code></pre>

					<p>For more information on using the Eureka Server on Cloud Foundry, see the <a target="_blank" href="https://docs.pivotal.io/spring-cloud-services/1-5/common/index.html">Spring Cloud Services</a> documentation.</p>

					<p>Once the service is bound to your application, the connection properties are available in <code>VCAP_SERVICES</code>. See <a href="https://steeltoe.io/docs/steeltoe-discovery/#reading-configuration-values">Reading Configuration Values</a> for more information on reading <code>VCAP_SERVICES</code>.</p>

					<h3 id="2-2-3-enable-logging">2.2.3 Enable Logging</h3>

					<p>Sometimes, it is desirable to turn on debug logging in the Eureka client. To do that simply add the following to your <code>appsettings.json</code>:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"Logging"</span>: {
					<span class="hljs-attr">"IncludeScopes"</span>: <span class="hljs-literal">false</span>,
					<span class="hljs-attr">"LogLevel"</span>: {
					<span class="hljs-attr">"Default"</span>: <span class="hljs-string">"Information"</span>,
					<span class="hljs-attr">"Pivotal"</span>: <span class="hljs-string">"Debug"</span>,
					<span class="hljs-attr">"Steeltoe"</span>:  <span class="hljs-string">"Debug"</span>
    }
  }
}
</code></pre>

					<h3 id="2-2-4-configuring-health-contributors">2.2.4 Configuring Health Contributors</h3>

					<p>The Eureka package provides two different Steeltoe Management Health contributors that can be used to monitor Eureka server health.</p>

					<p>The first one, <code>EurekaServerHealthContributor</code> is used to determine and report the health of the connection to the Eureka servers. It looks at the status of last good registry fetch and/or the last heartbeat attempt and using that information computes the health of the connection.</p>

					<p>If you use the <code>AddDiscoveryClient()</code> extension method and you have configured Eureka as your service discovery choice this contributor is automatically added to the container and will automatically picked up an used.</p>

					<p>The contributor is enabled by default, but can be disabled by setting <code>eureka:client:health:enabled=false</code>.</p>

					<p>The second contributor that you can enable is the <code>EurekaApplicationsHealthContributor</code>. This contributor is not enabled by default, so you must add it to the service container yourself:</p>

<pre><code class="csharp hljs">    services.AddSingleton&lt;IHealthContributor, EurekaApplicationsHealthContributor&gt;();
</code></pre>

					<p>The <code>EurekaApplicationsHealthContributor</code> can be used to report the health of a configurable list of registered services based on the status of the service in the registry. For each service it is configured to monitor it looks at all of the instances of that service and if all of the instances are marked <code>DOWN</code>, then the service will be reported in bad health.  You can configure the services that it monitors using the <code>eureka:client:health:monitoredApps</code> configuration setting.  Typically you would set this to the list of external service names the app is dependent on and if unavailable would impact the operation of the app.</p>

					<h3 id="2-2-5-configuring-health-checks">2.2.5 Configuring Health Checks</h3>

					<p>By default, Eureka uses the client heartbeat to determine if a client is up. Unless specified otherwise, the Eureka client does not propagate the current health status of the application as calculated by the health contributors configured for the application. Consequently, after successful registration, Eureka always announces that the application is in ‘UP’ state. This behavior can be altered by enabling Eureka health checks, which results in propagating application status to Eureka. As a consequence, every other application does not send traffic to applications in states other then ‘UP’.</p>

					<p>To enable this behavior you need to add the <code>IHealthCheckHandler</code> to your service container.  The handler is not added to the container by default.</p>

<pre><code class="csharp hljs">    services.AddSingleton&lt;IHealthCheckHandler, ScopedEurekaHealthCheckHandler&gt;();
</code></pre>

					<p>You can enable or disable the handler by using the following <code>eureka:client:health:checkEnabled</code> configuration settings.  It is enabled by default.</p>

					<p>If you require more control over the health check, consider implementing your own <code>IHealthCheckHandler</code>.</p>

					<h3 id="2-2-6-configuring-multiple-serviceurls">2.2.6 Configuring Multiple ServiceUrls</h3>

					<p>You can specify a comma delimited list of Eureka server URLs the client will use when registering or fetching the service registry. Those servers listed should be part of a properly configured Eureka server cluster and should be using peer to peer communications to keep in sync.</p>

					<p>The Eureka client will automatically failover to the other nodes in the cluster. When a failed Eureka server node comes back up, the Eureka client will automatically reconnect back to the server at some point.</p>

					<h3 id="2-2-7-configuring-metadata">2.2.7 Configuring Metadata</h3>

					<p>It is worth spending a bit of time understanding how the Eureka metadata works so you can use it in a way that makes sense in your application.</p>

					<p>There is standard metadata information such as hostname, IP address, port numbers, status page, and health check endpoint that is associated with every service registration. These are published in the service registry and are used by clients to contact the services in a straightforward way.</p>

					<p>Additional metadata can be added to instance registrations using the configuration setting <code>eureka:instance:metadataMap</code>. The metadata you supply using this configuration is added to the service registration and becomes accessible in remote clients.</p>

					<p>In general, additional metadata does not change the behavior of the client, unless the client is made aware of the meaning of the metadata.</p>

					<h1 id="3-0-hashicorp-consul">3.0 HashiCorp Consul</h1>

					<p>The following sections describe how to use the Consul client.</p>

					<ul>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-1-consul-settings">Consul Settings</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-2-enable-logging">Enable Logging</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-3-health-contributors">Health Contributor</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-4-configuring-health-check">Configuring Health Check</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-5-configuring-metadata">Configuring Metadata</a></li>
						<li><a href="https://steeltoe.io/docs/steeltoe-discovery/#3-2-6-configuring-instanceid">Configuring InstanceId</a></li>
					</ul>

					<p>You should know how the new .NET <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Configuration service</a> works before starting to use the client. A basic understanding of the <code>ConfigurationBuilder</code> and how to add providers to the builder is necessary in order to configure the client.</p>

					<p>You should also know how the ASP.NET Core <a target="_blank" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup">Startup</a> class is used in configuring the application services and the middleware used in the app. Pay particular attention to the usage of the <code>Configure()</code> and <code>ConfigureServices()</code> methods.</p>

					<p>It might be helpful to have an understanding of the <a target="_blank" href="https://spring.io/projects/spring-cloud-consul">Spring Cloud Consul</a> project as we have based our work on this project.</p>

					<p>In order to use the Steeltoe Discovery client, you need to do the following:</p>

					<ul>
						<li>Add appropriate NuGet package reference to your project.</li>
						<li>Configure the settings the Discovery client will use to register services in the service registry.</li>
						<li>Configure the settings the Discovery client will use to discover services in the service registry.</li>
						<li>Add and Use the Discovery client service in the application.</li>
						<li>Use an injected <code>IDiscoveryClient</code> to lookup services.</li>
					</ul>

					<blockquote>
						<p>NOTE: Most of the example code in the following sections is based on using Discovery in a ASP.NET Core application. If you are developing a ASP.NET 4.x application or a console-based app, see the <a target="_blank" href="https://github.com/SteeltoeOSS/Samples/tree/master/Discovery">other samples</a> for example code you can use.</p>
					</blockquote>

					<h3 id="3-2-1-consul-settings">3.2.1 Consul Settings</h3>

					<p>To get the Steeltoe Discovery client to properly communicate with the Consul server, you need to provide a few configuration settings to the client. There are two sections you may need to configure.  </p>

					<p>The first pertains to configuring the information needed to connect to the Consul server. All of these settings should start with <code>consul:</code></p>

					<table>
						<thead>
							<tr>
								<th>Key</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>host</td>
								<td>Address of the Consul server</td>
								<td>localhost</td>
							</tr>
							<tr>
								<td>port</td>
								<td>Port number the Consul server is listening on</td>
								<td>8500</td>
							</tr>
							<tr>
								<td>scheme</td>
								<td>Scheme to use with the Consul server (http or https)</td>
								<td>http</td>
							</tr>
							<tr>
								<td>datacenter</td>
								<td>The datacenter name passed in each request to the server</td>
								<td>none</td>
							</tr>
							<tr>
								<td>token</td>
								<td>The auth token passed in each request to the server</td>
								<td>true</td>
							</tr>
							<tr>
								<td>waitTime</td>
								<td>The time a Watch request blocks or waits</td>
								<td>none</td>
							</tr>
							<tr>
								<td>username</td>
								<td>Username for HTTP authentication</td>
								<td>none</td>
							</tr>
							<tr>
								<td>password</td>
								<td>Password for HTTP authentication</td>
								<td>none</td>
							</tr>
						</tbody>
					</table>

					<p>The second set of settings you may need to specify pertain to service registration and service discovery. All of these settings should start with <code>consul:discovery</code></p>

					<table>
						<thead>
							<tr>
								<th>Key</th>
								<th>Description</th>
								<th>Default</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>enabled</td>
								<td>Enable to disable the Consul client</td>
								<td>true</td>
							</tr>
							<tr>
								<td>register</td>
								<td>Whether to register as a service</td>
								<td>true</td>
							</tr>
							<tr>
								<td>deregister</td>
								<td>Whether to de-register on shutdown</td>
								<td>true</td>
							</tr>
							<tr>
								<td>serviceName</td>
								<td>The service name to register</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>scheme</td>
								<td>Scheme to register for service</td>
								<td>http</td>
							</tr>
							<tr>
								<td>hostname</td>
								<td>Hostname to use when registering server</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>ipAddress</td>
								<td>IP address to register</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>port</td>
								<td>Port number to register</td>
								<td>none</td>
							</tr>
							<tr>
								<td>preferIpAddress</td>
								<td>Register IP address instead of hostname</td>
								<td>false</td>
							</tr>
							<tr>
								<td>instanceId</td>
								<td>The instance id registered for service</td>
								<td>computed</td>
							</tr>
							<tr>
								<td>tags</td>
								<td>The list of tags used when registering a service</td>
								<td>none</td>
							</tr>
							<tr>
								<td>defaultQueryTag</td>
								<td>Tag to query for in service list if one is not listed in serverListQueryTags</td>
								<td>none</td>
							</tr>
							<tr>
								<td>queryPassing</td>
								<td>Enable or disable whether to add the ‘passing’ parameter to health requests. This pushes health check passing to the server.</td>
								<td>false</td>
							</tr>
							<tr>
								<td>registerHealthCheck</td>
								<td>Enable or disable health check registration</td>
								<td>true</td>
							</tr>
							<tr>
								<td>healthCheckUrl</td>
								<td>The health check URL override</td>
								<td>none</td>
							</tr>
							<tr>
								<td>healthCheckPath</td>
								<td>Alternate server health check path</td>
								<td>‘/actuator/health’</td>
							</tr>
							<tr>
								<td>healthCheckInterval</td>
								<td>How often to perform the health check</td>
								<td>10s</td>
							</tr>
							<tr>
								<td>healthCheckTimeout</td>
								<td>Timeout for health check</td>
								<td>10s</td>
							</tr>
							<tr>
								<td>healthCheckCriticalTimeout</td>
								<td>Timeout to de-register services critical for longer than this value</td>
								<td>30m</td>
							</tr>
							<tr>
								<td>healthCheckTlsSkipVerify</td>
								<td>Health check verifies TLS</td>
								<td>true</td>
							</tr>
							<tr>
								<td>instanceZone</td>
								<td>Instance zone to use during registration</td>
								<td>none</td>
							</tr>
							<tr>
								<td>instanceGroup</td>
								<td>Instance group to use during registration</td>
								<td>none</td>
							</tr>
							<tr>
								<td>defaultZoneMetadataName</td>
								<td>Metadata tag name of the zone</td>
								<td>‘zone’</td>
							</tr>
							<tr>
								<td>failFast</td>
								<td>Throw exception if registration fails</td>
								<td>true</td>
							</tr>
							<tr>
								<td>retry:enabled</td>
								<td>Enable or disable retry logic</td>
								<td>false</td>
							</tr>
							<tr>
								<td>retry:maxAttempts</td>
								<td>Max retries if retry enabled</td>
								<td>6</td>
							</tr>
							<tr>
								<td>retry:initialInterval</td>
								<td>Starting interval</td>
								<td>1000ms</td>
							</tr>
							<tr>
								<td>retry:maxInterval</td>
								<td>Maximum retry interval</td>
								<td>2000ms</td>
							</tr>
							<tr>
								<td>retry:multiplier</td>
								<td>Retry interval multiplier</td>
								<td>1.1</td>
							</tr>
							<tr>
								<td>heartbeat:enabled</td>
								<td>Enable or disable heartbeat logic</td>
								<td>false</td>
							</tr>
							<tr>
								<td>heartbeat:ttlValue</td>
								<td>Time to live heartbeat time</td>
								<td>30</td>
							</tr>
							<tr>
								<td>heartbeat:ttlUnit</td>
								<td>Time to live heartbeat unit</td>
								<td>s</td>
							</tr>
							<tr>
								<td>heartbeat:intervalRation</td>
								<td>The interval ration</td>
								<td>2.0/3.0</td>
							</tr>
						</tbody>
					</table>

					<h3 id="3-2-2-enable-logging">3.2.2 Enable Logging</h3>

					<p>Sometimes, it is desirable to turn on debug logging. To do that simply add the following to your <code>appsettings.json</code>:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"Logging"</span>: {
					<span class="hljs-attr">"IncludeScopes"</span>: <span class="hljs-literal">false</span>,
					<span class="hljs-attr">"LogLevel"</span>: {
					<span class="hljs-attr">"Default"</span>: <span class="hljs-string">"Information"</span>,
					<span class="hljs-attr">"Pivotal"</span>: <span class="hljs-string">"Debug"</span>,
					<span class="hljs-attr">"Steeltoe"</span>:  <span class="hljs-string">"Debug"</span>
    }
  }
}
</code></pre>

					<h3 id="3-2-3-health-contributor">3.2.3 Health Contributor</h3>

					<p>The Consul package provides a Steeltoe Management Health contributor (<code>ConsulHealthContributor</code>) that can be used to monitor Consul server health.</p>

					<p>If you use the <code>AddDiscoveryClient()</code> extension method and you have configured Consul as your service discovery choice this contributor is automatically added to the container and will automatically picked up an used.</p>

					<h3 id="3-2-4-configuring-health-check">3.2.4 Configuring Health Check</h3>

					<p>The health check for a Consul service instance defaults to <code>/actuator/health</code>, which is a good default when you have enabled the Steeltoe Management features in your application. You can change this path and provide your own implementation using the <code>consul:discovery:healthCheckPath</code> setting. Additionally, the interval that Consul uses to check the health endpoint may also be configured. You can change this setting using the <code>consul:discovery:healthCheckInterval</code>. You should use settings such as “10s” and “1m” to represent 10 seconds and 1 minute respectively.</p>

					<h3 id="3-2-5-configuring-metadata">3.2.5 Configuring Metadata</h3>

					<p>Consul does not yet support including metadata with service instance registrations, but the Steeltoe <code>IServiceInstance</code> has an <code>IDictionary&lt;string, string&gt; Metadata</code> property that is used to obtain metadata settings for an instance.</p>

					<p>The Steeltoe Consul client uses the Consul tags feature to approximate metadata registration until Consul officially supports associating metadata with instances.</p>

					<p>Tags with the form <code>key=value</code> will be split and used as <code>IDictionary</code> keys and values respectively. Tags without the equal sign will be used as both the key and value. You can add metadata with the <code>consul:discovery:tags</code> string array:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"consul"</span>: {
					<span class="hljs-attr">"discovery"</span>: {
					<span class="hljs-attr">"tags"</span>: [
					<span class="hljs-string">"somekey=somevalue"</span>,
					<span class="hljs-string">"someothervalue"</span>
      ]
    }
  }
}
</code></pre>

					<p>The above tag list results in metadata that looks like this:</p>

<pre><code class="json hljs">{
					<span class="hljs-attr">"somekey"</span>: <span class="hljs-string">"somevalue"</span>,
					<span class="hljs-attr">"someothervalue"</span>: <span class="hljs-string">"someothervalue"</span>
}
</code></pre>

					<h3 id="3-2-6-configuring-instanceid">3.2.6 Configuring InstanceId</h3>

					<p>By default, if no other values are configured, a Consul service instance is registered with an ID that is equal to the applications name concatenated with a random value.</p>

					<p>You can change that by configuring the setting <code>spring:application:instance_id</code> or <code>vcap:application:instance_id</code> to some value and then the ID will be equal to the applications name concatenated with that value.  Note that on Cloud Foundry, <code>vcap:application:instance_id</code> will automatically be set for you if you use the Steeltoe Cloud Foundry configuration provider.</p>

					<p>You can completely override all of the above by setting <code>consul:discovery:instanceId</code> to some value instead.</p>

					<h1 id="common-steps">Common Steps</h1>

					<p>This section describes tasks that are common to many of the processes described in this guide.</p>

					<h2 id="publish-sample">Publish Sample</h2>

					<h3 id="asp-net-core">ASP.NET Core</h3>

					<p>Use the <code>dotnet</code> CLI to <a target="_blank" href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish">build and locally publish</a> the application for the framework and runtime you will deploy the application to:</p>

					<ul>
						<li>Linux with .NET Core: <code>dotnet publish -f netcoreapp2.1 -r ubuntu.14.04-x64</code></li>
						<li>Windows with .NET Core: <code>dotnet publish -f netcoreapp2.1 -r win10-x64</code></li>
						<li>Windows with .NET Platform: <code>dotnet publish -f net461 -r win10-x64</code></li>
					</ul>

					<blockquote>
						<p>NOTE: Starting with .NET Core 2.0, the <code>dotnet publish</code> command will automatically restore dependencies for you. Running <code>dotnet restore</code> explicitly is not generally required.</p>
					</blockquote>

					<h3 id="asp-net-4-x">ASP.NET 4.x</h3>

					<ol>
						<li>Open the solution for the sample in Visual Studio</li>
						<li>Right click on the project, select “Publish”</li>
						<li>Use the included <code>FolderProfile</code> to publish to <code>bin/Debug/net461/win10-x64/publish</code></li>
					</ol>

					<h2 id="push-sample">Push Sample</h2>

					<p>Use the Cloud Foundry CLI to push the published application to Cloud Foundry using the parameters that match what you selected for framework and runtime:</p>

<pre><code class="bash hljs"><span class="hljs-comment"># Push to Linux cell</span>
cf push <span class="hljs-_">-f</span> manifest.yml -p bin/Debug/netcoreapp2.1/ubuntu.14.04-x64/publish

<span class="hljs-comment"># Push to Windows cell, .NET Core</span>
cf push <span class="hljs-_">-f</span> manifest-windows.yml -p bin/Debug/netcoreapp2.1/win10-x64/publish

<span class="hljs-comment"># Push to Windows cell, .NET Framework</span>
cf push <span class="hljs-_">-f</span> manifest-windows.yml -p bin/Debug/net461/win10-x64/publish
</code></pre>

					<blockquote>
						<p>NOTE: Manifest file names may vary. Some samples use a different manifest for .NET 4 vs .NET Core.</p>
					</blockquote>

					<!-- -->

					<blockquote>
						<p>NOTE: All sample manifests have been defined to bind their application to their service(s).</p>
					</blockquote>

					<h2 id="reading-configuration-values">Reading Configuration Values</h2>

					<p>Once the settings have been defined, the next step is to read them so that they can be made available to the connector.</p>

					<p>The next example reads settings from the <code>appsettings.json</code> file with the .NET JSON configuration provider (<code>AddJsonFile("appsettings.json")</code>) and from <code>VCAP_SERVICES</code> with <code>AddCloudFoundry()</code>. Both sources are then added to the configuration builder, as follows:</p>

<pre><code class="csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> {
    ...
					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IWebHost <span class="hljs-title">BuildWebHost</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)
    </span>{
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebHostBuilder()
            ...
            .UseCloudFoundryHosting()
            ...
            .ConfigureAppConfiguration((builderContext, configBuilder) =&gt;
            {
					<span class="hljs-keyword">var</span> env = builderContext.HostingEnvironment;
                configBuilder.SetBasePath(env.ContentRootPath)
                    .AddJsonFile(<span class="hljs-string">"appsettings.json"</span>, optional: <span class="hljs-literal">true</span>, reloadOnChange: <span class="hljs-literal">true</span>)
                    .AddJsonFile(<span class="hljs-string">$"appsettings.<span class="hljs-subst">{env.EnvironmentName}</span>.json"</span>, optional: <span class="hljs-literal">true</span>)
                    .AddEnvironmentVariables()
					<span class="hljs-comment">// Add to configuration the Cloudfoundry VCAP settings</span>
                    .AddCloudFoundry();
            })
            .Build();
    }
    ...
</code></pre>

					<p>When pushing the application to Cloud Foundry, the settings from service bindings merge with the settings from other configuration mechanisms (such as <code>appsettings.json</code>).</p>

					<p>If there are merge conflicts, the last provider added to the Configuration take precedences and overrides all others.</p>

					<p>To manage application settings centrally instead of with individual files, use <a href="https://steeltoe.io/docs/steeltoe-configuration">Steeltoe Configuration</a> and a tool such as <a target="_blank" href="https://github.com/spring-cloud/spring-cloud-config">Spring Cloud Config Server</a></p>

					<blockquote>
						<p>NOTE: If you use the Spring Cloud Config Server, <code>AddConfigServer()</code> automatically calls <code>AddCloudFoundry()</code> for you</p>
					</blockquote>

					<a class="repo-link" target="_blank" href="https://github.com/steeltoeoss/steeltoe-site/tree/dev/source/docs/steeltoe-discovery.html.markdown">Create a pull request or raise an issue on the source for this page in GitHub</a>
				</div>
			</div>
		</div>
	</div>
	<script src="/javascripts/vendor/gumshoe.js"></script>
	<script src="/javascripts/vendor/highlight.min.js"></script>
	<script src="/javascripts/vendor/jquery-3.1.1.slim.min.js"></script>
	<script src="/javascripts/vendor/particles.min.js"></script>
	<script src="/javascripts/vendor/smooth-scroll.js"></script>
	<script src="/javascripts/vendor/sticky-kit.min.js"></script>
	<script src="/javascripts/vendor/svg-injector.min.js"></script>
	<script src="/javascripts/vendor/tocbot.min.js"></script>
	<script src="/javascripts/all.js"></script>
	<script src="/javascripts/docs.js"></script>
	<script>
		function viewV1() {
			window.location.href = '/1x/steeltoe-configuration/';
		}
				//document.getElementById('docselector').style.display = "inline";
	</script>


</body>
</html>